---
title: ".daddy_code v2.0"
author: "Rasmus Hammar, Hjalte Sveidqvist"
format:
  html: 
    highlight-style: atom-one
    toc: true
    number-sections: true
    number-depth: 4
    embed-resources: true
    self-contained-math: true
    code-overflow: wrap
  docx: 
    highlight-style: atom-one
    toc: true
    number-sections: true
    number-depth: 4
  pdf:
    highlight-style: atom-one
    toc: true
    number-sections: true
    number-depth: 4
include-in-header: 
  text: |
    \usepackage{fvextra}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
editor: visual
execute: 
  echo: true
editor_options: 
  chunk_output_type: console
---

{{< pagebreak >}}

# Allmänt

Lite allmänna funktioner som är bra att kunna.

## Paket & inläsning av data

För att installera ett paket.

```{r}
#| eval: false
# För att installera paketet som heter palmerpenguins
install.packages("palmerpenguins")

# Stats
install.packages("MKinfer")
install.packages("lmboot")
install.packages("boot.pval")

# Matte
install.packages("pracma")
install.packages("expm")
install.packages("deSolve")

# KvantBio
install.packages("plotrix")
install.packages("scales")
```

För att använda funktioner i ett paket måste man ladda in paketet i R genom `library()`

```{r}
#| output: false
#| warning: false
# Exempel data
library(palmerpenguins)

# Stats
library(MKinfer)
library(lmboot)
library(boot.pval)

# Matte
library(pracma)
library(expm)
library(deSolve)

# KvantBio
library(plotrix)
library(scales)
```

För att läsa in data från t.ex. en .csv eller .txt fil. Öppna filen och identifiera vilka symboler som **sep**arerar kolumner samt används som **dec**imaltecken.

```{r}
#| eval: false
file.choose() # Returnerar vägen till filen man väljer, hitta fönstret med alt + tab.

my_data <- read.table(
  file = file.choose(), # Välj fil interaktivt, alt. filens sökväg som en text string
  header = TRUE, # Om det finns namn på kolumnerna
  sep = ",", # Här används ett kommatecken för att skilja på kolumner
  dec = "." # Här används en punkt som decimaltecken
)
```

För att titta på data kan man använda

```{r}
# View(penguins) # Öppnar som separat flik
head(penguins, # Printar de första n raderna
     n = 3)
tail(penguins, # Printar de sista n raderna
     n = 3)
```

För att skapa olika datastrukturer

## Variabel

```{r}
var_1 <- "Text/character string" # Någonting inuti "" är text
var_2 <- 25 # Nummer, för decimaltal 25.99
var_3 <- TRUE # Boolean, kan bara vara TRUE (T) eller FALSE (F)
var_4 <- NA # Not Available (NA), inte samma som "NA" (text string)!
var_5 <- NULL # Ingenting, tenderar att radera saker!
```

## Vektor

```{r}
vec_1 <- c() # Skapar en tom vektor
vec_1 <- c(36, 56, 48) # Skapa en vektor med tre värden
vec_1[4] <- 25 # Sätta in ett värde i index plats 4
vec_1 # Printa innehållet av variablen (vektorn)
```

```{r}
#| eval: false
vec_1[2] # Printa innehållet i index 2
```

```{r}
#| eval: false
vec_1[c(1,3)] # Printa index 1 och 3
```

Vektorer kan innehålla namn och indexeras med namn

```{r}
vec_2 <- c(element_1 = 99, element_2 = 100, element_3 = 101)
vec_2["element_4"] <- 102 # Sätt in ett värde med namn
vec_2
```

```{r}
#| eval: false
vec_2["element_2"]
```

```{r}
#| eval: false
vec_2[c("element_1", "element_3")]
```

## Data frame

```{r}
df <- data.frame( # Skapa en dataframe med kolumn_namn = vektor
  vec_1, # Kolumn 1, vec_1 från tidigare
  letters = LETTERS[1:4] # Kolumn 2, lite bokstäver
)
df
```

Man kan lägga till kolumner med \$

```{r}
df$col_3 <- vec_2 # Kolumn 3
df
```

Andra sätt att lägga till kolumner är med namn

```{r}
df["col4"] <- letters[1:4]
df
```

En kolumn kan användas med \$ vilket ger en vektor (viktig distinktion vid vissa andra tillfällen).

```{r}
#| eval: false
df$letters # Ger en vektor, samma som med df[["letters]]
```

Eller med indexering/namn, N.B. enkla `[ ]` ger ett subset, alltså en mindre del av samma objekt typ

```{r}
#| eval: false
df[3] # Ger en data frame med enbart kolumn 3
df["col4"] # Ger en data frame med kolumn "col4"
```

medan dubbla `[[ ]]` ger objektet inuti

```{r}
#| eval: false
df[[1]] # Ger det "mindre objektet inuti", alltså en vektor i detta fall
```

Enkla `[ ]` kan indexeras med rader och kolumner samtidigt

```{r}
#| eval: false
df[2] # Kolumn 2 (en data frame med en kolumn)
df[3,2] # Rad 3, kolumn 2 (en vektor av längd ett)
df[ ,2] # Alla rader, kolumn 2 (en vektor)
df[3, ] # Rad 3, alla kolumner (en data frame med en rad)
```

På tal om subsetting, för att ta ett subset av en data frame kan man filtrera rader baserat på ett kriterium

```{r}
penguins_chin <- penguins[penguins$species == "Chinstrap", ] 
# Utan komma läses det som att du vill filtrera kolumner! '==' är det matematiska 'lika med' (eftersom '=' är samma som '<-' )
head(penguins_chin, 3)

penguins_heavy <- penguins[penguins$body_mass_g > 3500, ]
head(penguins_heavy, 3)
```

Man kan även göra detta för att få en kolumn filtrerad/subset baserad på en annan kolumn.

```{r}
#| eval: false
penguins_chin_weight <- penguins$body_mass_g[penguins$species == "Chinstrap", ]
```

`Error in penguins$body_mass_g[penguins$species == "Chinstrap", ] :    incorrect number of dimensions`

Det blir en error därför att nu försöker man ta både rader och kolumner (2 dimensioner) på en kolumn (kolumn/vektor har bara 1 dimension) därför att \$ ger en vektor. Om vi istället provar utan extra kommatecken för att ange rader & kolumner samtidigt fungerar det (ger en vektor). Alternativt ange kolumnen med namn istället för med \$ (ger en mindre data frame).

```{r}
# Utan extra kommatecken
penguins_chin_weight <- penguins$body_mass_g[penguins$species == "Chinstrap"]
head(penguins_chin_weight)

# Ange kolumnen med namn
penguins_chin_weight <- penguins[penguins$species == "Chinstrap", "body_mass_g"]
head(penguins_chin_weight)
```

Vi kan även bli av med `NA` på ett kontrollerat sätt med den här metoden. Om man vill se till att vikt och näbblängd inte har `NA` kan man använda funtionen `in.na()` och operatorn `!`.

```{r}
is.na(NA) # Kolla om NA är NA
!is.na(NA) # ! negerar ett TRUE/FALSE uttryck

vec_NA <- c(NA, 50)
is.na(vec_NA) # Kolla vilka element som är NA
!is.na(vec_NA)
```

```{r}
# Alla rader där kolumnen body_mass_g inte är NA och alla kolumner
penguins_no_NA <- penguins[!is.na(penguins$body_mass_g), ]
# Alla rader där kolumnen bill_length_mm inte är NA och alla kolumner
penguins_no_NA <- penguins_no_NA[!is.na(penguins_no_NA$bill_length_mm), ]

# Tabell med antal rader & kolumner
data.frame(
  rows = c(penguins = nrow(penguins), no_NA = nrow(penguins_no_NA)),
  columns = c(penguins = ncol(penguins), no_NA = ncol(penguins_no_NA))
)
```

## Matris

Vi kan skapa matriser med `rbind()` (går även att använda `cbind()` men då placeras vektorerna vertikalt från det övre vänstra hörnet, istället för horisontellt). Med `rbind()` blir matrisen som den ser ut när man skriver den.

```{r}
rbind( # en "character matrix"
  c("a", "b"),
  c("c", "d")
)

cbind( # skillnaden med cbind()
  c("a", "b"),
  c("c", "d")
)

M <- rbind( # Skapar en matris radvis med namngivna rader och kolumner
  r1 = c(col1 = 0.90, col2 = 0, col3 = 0, col4 = 0, col5 = 0.45),
  r2 = c(          0,     0.45,        0,        0,           0),
  r3 = c(          0,     0.23,     0.45,        0,           0),
  r4 = c(          0,        0,     0.23,     0.45,           0),
  r5 = c(          0,        0,        0,     0.23,        0.20)
)
M
```

För matris matte se [Matte] sektionen.

Matriser kan indexeras ungefär på samma sätt som data frames.

```{r}
#| eval: false
M[3, 2]
M[3:5, 2:3]
M[c(3,5), c(2,3)]
M[c("r3","r5"), c("col2","col3")]
```

## Lista (den riktiga listan)

I en vektor **måste** alla element vara av samma typ (numerisk/text osv.) och i en data frame **måste** alla kolumner (som är vektorer) vara lika långa.

Listor kan ha olika typer av objekt i sig och brukar användas för att bunta ihop olika objekt man vill hålla tillsammans. Till exempel är output från `t.test()` en lista.

```{r}
my_list <- list() # En tom lista
my_list$df_1 <- df # Lägg till en data frame med $
my_list[[2]] <- var_2 # Lägg till en variabel med index, N.B. [[]]
my_list[["plats_3"]] <- vec_2 # Lägg till en vektor med namn, N.B. [[]]
my_list
```

Och man få ut objekten i en lista på samma sätt.

## Lite andra funktioner

Ett objekts typ heter "klass" och kan kollas med funktionen `class()`

```{r}
#| eval: false
class(var_1) # var_1 är text
class(var_2) # var_2 är numerisk
class(var_3) # var_3 är logical/boolean (TRUE/FALSE)
class(vec_1) # vec_1 är numerisk vektor
class(df) # df är en data frame
class(M) # M är en matris
class(my_list) # my_list är en lista
```

För att se till att någonting skrivs i konsollfönstret används `print()`

```{r}
print(var_1) # Tar enbart ett objekt! Se paste()

```

För att skriva ihop text m.m. används `paste()`, den tar dock enbart enskilda element (inte vektor/data frame/list

```{r}
message <- paste(
  "Hello", "world", var_1, 55, vec_2[3], # Alla objekt man vill skriva ihop
  sep = " " # Separator att infoga mellan varje objekt, här ett mellanslag
)
print(message)
```

Notera att `print()` enbart accepterar ett objekt, därav den vanliga kombinationen `print(paste(arg1, arg2))`.

```{r}
print(paste("Nu","klarar","vi","tentan!", sep = "! "))
```

Kolla längden på saker med

```{r}
#| eval: false
length(vec_1) # Längden på en vektor
length(penguins) # Längden på en data frame är antalet kolumner
nrow(penguins) # För antalet rader i en data frame
ncol(penguins) # Antalet columner på en data frame
```

Få en vektor med namnen på kolumner

```{r}
colnames(penguins)
```

Få alla unika element i en vektor

```{r}
unique(penguins$species)
```

Konvertera/tvinga (eng. coerce) objekt till en viss typ.

```{r}
#| eval: false
as.numeric()    # Bra ifall en kolumn är text men ska vara siffror
as.character()
as.factor()     # Kan vara viktig för ANOVA om grupperna är 1,2,3,4...

as.data.frame() # Kan tvinga en matris till data frame
as.matrix()     # Kan tvinga en data frame till matris
```

## Kontrollstrukturer

Kontrollstrukturer är några speciella funktioner som möjliggör mer kontroll över vilka rader med kod som ska köras.

### Loop

För att köra några rader kod flera gånger används loopar. Detta är exempel på for-loop.

```{r}
vector <- c("Nu", "klarar", "vi", "tentan!")
for (variable in vector) {
  print(variable)
}

for (i in 1:4) {
  print(paste(i, ":", vector[i]))
}

n <- c()
n[1] <- 55
for (i in 1:5) {
  n[i+1] <- i
}
n
```

### If-else

För att köra vissa rader enbart om ett visst kriterium uppfylls används if-else kombination. Resultatet av att "köra koden" i parantesen ska bli `TRUE` för att köra den följande koden.

```{r}
if ("Tenta!" == "Tenta!") { # Blir TRUE
  print(TRUE)
} else {
  print(FALSE)
}

if (5^2 < 100) { # Blir TRUE
  print("Smaller")
} else {
  print("Bigger")
}

if (50^2 < 100) { # Blir FALSE
  print("Smaller")
} else {
  print("Bigger")
}

```

## Plotting

Här följer plotfunktioner med många möjliga argument. Vissa argument visas flera gånger som alternativ.

För att kontrollera hur många plots att visa på samma gång, använd.

```{r}

```

### Tomt plotfönster

```{r}
plot(
  x = NULL,
  y = NULL,
  
  xlim = c(0, 250),
  ylim = c(0, 500),
  
  xlab = "x-axis",
  ylab = "y-axis",
  main = "Empty plot"
)
```

### Scatterplot

Om x = kontinuerlig & y = kontinuerlig ger detta ett punktdiagram eller linjediagram.

De flesta argument fungerar likadant/liknande för andra typer av plots.

```{r}
plot(
  # Värden för axlarna
  x = penguins$bill_depth_mm,
  y = penguins$body_mass_g,
  
  # Annotering
  xlab = "Bill depth [mm]",
  ylab = "Body mass [g]",
  main = "Hefty penguins!",
  sub = "An analysis by island",
#  ann = FALSE, # alt. ta bort alla vanliga annoteringar.
  
#  xaxt = "n",  # x-axis text = 'n' (none)
#  yaxt = "n",    # Tar bort axel markörerna
  
  # Linjer & punkter
  type = "p",   # 'l' = line, 's' = stairs, 'p' = point, 
                  # 'b' = both (line & pont), 'o' = both (overplotted),
                  # 'h' = histogram liknande, 'n' = none.
  pch = 16,     # 15 = ifylld kvadrat, 16 = ifylld prick,
                  # 17 = ifylld triangel, 18 = ifylld diamant.
  cex = 1,      # Storlek på punkt.

#  lwd = 3,     # Storlek på linje.
#  lty = 1,     # "blank", "solid", "dashed", "dotted", 
                  # "dotdash", "longdash", twodash".

# col = "blue",  # Färg
  col = penguins$island, # Färg baserat på faktor
# col = alpha("blue", 0.30) # Färg (blå) & transparens (30%)
)

# Lägg till en linje från 'a' till 'b'.
abline(
#  a = intercept,
#  b = slope,
  h = 4000, # y-värde för horizontella linjer
  v = 14,   # x-värde för vertikala linjer
#  reg = lm_objekt, # Regressionsmodell, se sektion 2.4.2.4 Predict
  col = "purple"
)

# För att lägga till en legend
legend(
#  x = 20, y = 6000, # x & y koordinater för legenden.
  
  x = "topright",    # Kan ges "top", "topleft", "topright",
                       # "bottom", "bottomleft", "bottomright".
  inset = 0.05,      # Avstånd till ytterkanterna som en % av plot storleken. 
  
  legend = c("Island 1", "Island 2", "Island 3"), # Namn i legenden.
  pch = 16,  # Sätt olika punkter med c(15, 16, 17). (Krävs för färger!)
  col = 1:3, # Eftersom faktorn har tre grupper. 
               # Kan även vara c("blue","green","orange").
  
#  lty = c(1, 2, 3), # Sätt olika linje typer,
#  fill = 1:3,       # Färg, men utan att ange form/linje.

  title = "Legend", # Legend title
  bty = "o",        # 'o' = box, 'n' = no box, eller '7', 'L', 'U', 'C'.
)
```

### Boxplot

Om x = faktor & y = kontinuerlig ger detta en boxplot/låddiagram.

```{r}
plot(
  x = penguins$species,
  y = penguins$flipper_length_mm,
  
  xlab = "Species",
  ylab = "Flipper length [mm]",
  main = "Flipper length by species",
  
  col = c("skyblue", "darkgreen", "orange")
)
```

```{r}
boxplot(
  flipper_length_mm ~ species * sex,
  data = penguins,
  col = c("blue","skyblue",
          "darkgreen","green",
          "darkorange","orange")
)
```

### Barplot

Om x = faktor & inget y ger detta en barplot/stapeldiagram.

```{r}
plot(
  x = penguins$species,
  
  xlab = "Species",
  ylab = "Frekvens/antal",
  
  col = c("skyblue", "darkgreen", "orange")
)
```

### Histogram

```{r}
hist(
  penguins$flipper_length_mm,
  main = "Histogram för flipper length",
  xlab = "Flipper length [mm]",
  
#  breaks = 99,   # Hur många staplar
#  col = "blue",  # Färg
)
```

### Error plot med `plotCI()`

Används för att illustrera medelvärdet (en punkt) $\pm$ standardavvikelse eller standard error of the mean (SEM, se 2.1 Enkel statistik).

```{r}
# Data för att plotta
peng_mean <- aggregate(
  flipper_length_mm ~ species,
  data = penguins,
  FUN = mean
)
peng_sd <- aggregate(
  flipper_length_mm ~ species,
  data = penguins,
  FUN = sd
)

# Plot
plotCI(
  x = c(2,3,4), # x-koordinater att placera punkter på
  y = peng_mean$flipper_length_mm, # y-koordinater att placera punkter på
  
  xlab = "Species",
  ylab = "Flipper length [mm]",
  
  # Upper interval, alltså övre gränsen för sträcken, är lika med
    # medelvärdet + standardavvikelsen
  ui = peng_mean$flipper_length_mm + peng_sd$flipper_length_mm,
  # Lower interval, alltså den nedre gränsen, är lika med
    # medelvärdet - standardavvikelsen
  li = peng_mean$flipper_length_mm - peng_sd$flipper_length_mm,
  
  xlim = c(1.75,4.25), # För att ge lite extra plats på sidorna
  
  xaxt = "n", # Ta bort siffrorna på x-axeln
  
  pch = 16,
  col = c("skyblue", "darkgreen", "orange")
)
axis(
  side = 1, # vilken sida/axel att lägga till (1 = botten, 2 = vänster, osv.)
  at = c(2,3,4), # Vid vilka x-koordinater att placera text
  labels = peng_mean$species # Lägg till arterna på x-axeln
)
```

### Plot av funktion

```{r}
# Definiera en funktion som en funktion med bara ett argument.
curve_fun <- function(x) {
  10^(0.36*x+1.945)
}

curve(
  10^(0.10*S+1.745), # Matematiska funktionen att rita
  xname="S",         # Vad 'x' heter om man ger den matematiska funktionen direkt
  xlim=c(0,100),     # Intervallet
  col = "blue"
)
curve(
  curve_fun,         # Namn på funktionen med funktionen
  xlim = c(0,100),
  col = "darkorange",
  add = TRUE         # Lägg till linjen i existerande graf
)
```

{{< pagebreak >}}

# Stats

### Tolkning av p-värde

Drivna över bristningsgränsen av kursen har en student blivit galen och vandrar, med slö blick, vilset i stadsskogen. Studenten betraktar ett träd. Hur högt är trädet? Vilsen betraktar studenten ett annat träd och stapplar vidare. Vad är sannolikheten att genomsnittshöjden på de träd studenten slumpmässigt observerar skiljer sig från genomsnittshöjden på alla träd i stadsskogen? Kanske de skiljer sig från träden i fjällen?

-   **H~0~** = Ingen skillnad mellan medelvärden

-   **H~1~** = Skillnad mellan medelvärden

p-värdet är sannolikheten att en stackars vilsen student slumpmässigt skulle betrakta dessa träd och konstatera att deras höjd skiljer sig från resten av skogens (alltså acceptera **H~1~**), när det i verkligheten inte finns någon skillnad mellan observerade och skogens medelvärden (alltså om **H~0~** är sann).

-   Om p-värde \> alfa, alltså p \> 0.05, säger vi att det inte finns en skillnad (acceptera **H~0~**).

-   Om p-värde \< alfa, alltså p \< 0.05, säger vi att det finns en skillnad (acceptera **H~1~**).

### Rapportera test

Rapportera alltid testets namn, statistiken (t.ex. t-/F-värdet), frihetsgrader och p-värde, samt en mening som ger slutsatsen/tolkningen av testet. Andra relevanta saker kan också inkluderas, såsom konfidens intervall.

Exempel: Förklarande mening (\[testets namn\], t(\[frihetsgrader\]) = \[värdet\], p = \[värdet\]).

> Det fanns en skillnad mellan Grupp 1 och den förväntade vikten (mu = 3000 g) enligt internet (One sample t-test, t(150) = 18.776, p \< 2.2e-16).

Tips från coachen, gör detta snyggare än jag...

### Formel notation

Många av funktionerna för de statistiska testen kan, eller måste, ges en formel. Formler har följande komponenter:

-   *Respons*, en kontinuerlig variabel vi vill förutspå, värdet på y-axeln

-   *Faktor*, en kategorisk variabel vilken delar in *Respons* i grupper (för regression är detta en kontinuerlig variabel som direkt orsakar *Respons*)

-   '\~', skiljer *Respons* från *Faktor*, alltså ger Vänster- och Högerled (`Respons ~ Faktor`)

-   '+', adderar en ytterligare *Faktor* (`Respons ~ Faktor_1 + Faktor_2`)

-   '\*', adderar en ytterligare *Faktor* **och** interaktionen (`Respons ~ Faktor_1 * Faktor_2` )

-   ':', adderar enbart interaktionen (`Respons ~ Faktor_1:Faktor_2`)

{{< pagebreak >}}

### Beslutsschema

![Stats flowchart 1](Beslutsschema-1.png)

{{< pagebreak >}}

![Stats flowchart 2](Beslutsschema-2.png)

{{< pagebreak >}}

![Stats flowchart 3](Beslutsschema-3.png)

{{< pagebreak >}}

![Stats flowchart 4](Beslutsschema-4.png)

{{< pagebreak >}}

## Enkel statistik

Några enkla/grundläggande statistik funktioner.

```{r}
mean(penguins$bill_length_mm, na.rm = TRUE)   # Medelvärde
median(penguins$bill_length_mm, na.rm = TRUE) # Median
sum(penguins$bill_length_mm, na.rm = TRUE)    # Summa av vektor
sd(penguins$bill_length_mm, na.rm = TRUE)     # Standardavvikelse

# Funktioner som ger vektorer med svar. Fungerar på både matriser & data frames!
# N.B. stor bokstav i mitten! Finns andra funktioner med liknande namn.
rowSums(M)  # ger en (kolumn) vektor med summan för varje rad.
colSums(M)  # ger en (rad) vektor med summan för varje kolumn.
rowMeans(M) # Samma, men för medelvärde.
colMeans(M) # Samma, men för medelvärde.
```

```{r}
# Aggregate är lite speciell. Den grupperar rader efter en faktor och applicerar en annan funktion på varje grupp.
aggregate(
  bill_length_mm ~ island,
  data = penguins,
  FUN = mean, # Använd 'mean' eller 'median'
)
```

Standard error of the mean (SEM) finns det ingen egen funktion för, men vi kan skapa en. Formeln är $SEM = \frac{Sd}{\sqrt{n}}$ , där Sd = standardavvikelse och n = antal observationer. SEM beskriver hur exakt/pålitligt medelvärdet är om det används som det sanna medelvärdet för populationen.

```{r}
SEM <- function(x, na.rm = FALSE) {
  # Om argumentet na.rm = TRUE, ta bort NA från x
  if (na.rm) {
    x <- na.omit(x)
  }
  
  # Beräkna SEM
  SEM <- sd(x)/sqrt(length(x))
  return(SEM)
}

SEM(penguins$bill_length_mm, na.rm = TRUE)
```

## Transformation

Om data inte ser nice ut, prova att transformera data (för paired/beroende transformera differensen). För denna kurs prova logaritmering.

```{r}
#| eval: false
log()   # Basen e
log10() # Basen 10
```

## Sannolikhet

### Slumpade tal

Slumpa ett tal från normalfördelning. Ungefär 96 % av alla observationer i en normalfördelad population ligger inom $\pm$ två standardavvikelser.

```{r}
rnorm(
  n = 5,    # Antal tal
  mean = 0, # Väntevärde för fördelningen
  sd = 1    # Standard avvikelse
)
```

Slumpade tal från binomialfördelning. Ger n tal där varje tal är hur många gynnsamma utfall det blev, baserat på totalt antal försök och sannolikheten.

```{r}
rbinom(
  n = 5,     # Antal tal
  size = 10, # Totalt antal försök
  prob = 0.5 # Sannolikhet för gynnsamt utfall
)
```

Slumpade tal från en uniform fördelning (samma sannolikhet för för varje tal).

```{r}
runif(
  n = 5,   # Antal tal
  min = 0, # Nedre intervall
  max = 10 # Övre intervall
)
```

### Binomial fördelning

Min binomiala studie:

-   20 försök

-   varje försök är Ja/Nej

-   37 % sannolikhet för Ja för varje oberoende försök

För utfall med binomial fördelning används `dbinom()` för att beräkna sannolikheten för exakt x antal gynsamma utfall.

```{r}
f5 <- dbinom(
  x = 5, # Exakt antal 'Ja'
  size = 20, # Totalt antal försök
  prob = 0.37 # Sannolikheten för försöket
)
print(paste("Sannolikhet att exakt fem av 20 försök blir 'Ja':", f5))
```

Dessa sannolikheter kan adderas.

```{r}
f6 <- dbinom(
  x = 6, # Exakt 6st Ja
  size = 20,
  prob = 0.37
)
print(paste("p att exakt 5-6st av 20 försök blir 'Ja':", (f5+f6)))
```

eller `1 - pbinom()` för att beräkna sannolikheten för alla utfall **över** det man anger.

```{r}
f15_20 <- (1 - pbinom(
  q = 14, # utfall över det angivna
  size = 20,
  prob = 0.37
))
print(paste("p att få 15 eller fler 'Ja':",f15_20))
```

Enbart `pbinom()` ger den motsatta sannolikheten (alltså 0-14 Ja) vilket är kompliment till 15-20 Ja. Använd `lower.tail = FALSE` för att få 15-20 Ja istället.

```{r}
f15_20_igen <- pbinom(
  q = 14,
  size = 20,
  prob = 0.37,
  lower.tail = FALSE # Istället för 1 - pbinom()
)
print(paste("p att få 15 eller fler 'Ja':",f15_20_igen))
```

## Skillnad mellan grupper

### T-test

#### Krav/antaganden

-   Data på intervall eller kvotskala (kontinuerlig)

-   Normalfördelad (parametrisk) inom varje grupp

-   Lika varians (homogen varians, ej för Welch t-test)

-   Inga outliers

```{r}
group_1 <- penguins$body_mass_g[penguins$species == "Adelie"]

par(mfrow = c(1,2)) # Ändrar hur många "rutor/celler" för 
# plots det finns enligt rad x column. Bra vana att alltid 
# ändra tillbaka till standard c(1,1) efteråt. 

hist(group_1)

qqnorm(group_1)
qqline(group_1, col = "red")

par(mfrow = c(1,1)) # Ändra tillbaka inställningarna.
```

#### Ensidigt

För att testa om en grupp med kontinuerlig data skiljer sig från ett känt eller teoretiskt väntevärde.

```{r}
grupp_1 <- penguins$body_mass_g[penguins$species == "Adelie"]

t.test(
  x = grupp_1, # En vektor
  mu = 3000    # Väntevärdet vi hittade på internet
)
```

##### Resultat:

Det fanns en skillnad mellan Grupp 1 och den förväntade vikten enligt internet (One sample t-test, t(150) = 18.776, p \< 2.2e-16).

#### Tvåsidigt

För att testa om det finns en skillnad mellan två grupper av kontinuerlig data.

```{r}
grupp_1 <- penguins$body_mass_g[penguins$species == "Adelie"]
grupp_2 <- penguins$body_mass_g[penguins$species == "Gentoo"]

t.test(
  x = grupp_1, # En vektor
  y = grupp_2, # En annan vektor
)
```

Alternativt sätt att skriva koden är med formel.

```{r}
peng_groups <- penguins[ which(penguins$species == "Adelie" | penguins$species == "Gentoo"), ]

t.test( # Respons = mätdata & Faktor = två olika arter (alltså två grupper)
  body_mass_g ~ species,
  data = peng_groups
)
```

##### Resultat:

Det fanns en skillnad mellan Grupp 1 och Grupp 2 (Welch two sample t-test, t(249.64) = -23.386, p \< 2.2e-16).

#### Paired/beroende

First rule of Crayfish Fight Club is you do not talk about Crayfish Fight Club.

Vi studerar kräftor och vill undersöka vilken effekt storleken på klorna har på vilken kräfta som vinner strider om resurser. För att göra detta snorklar vi någonstans tropiskt och letar efter kräftor som slåss. Efter några månader "hårt arbete" har vi samlat ihop följande data. Varje rad är storleken på klorna i cm med vinnare och förlorare i respektive kolumn.

```{r}
crayfish_fight_club <- data.frame(
  winner = c(86, 84, 75, 93, 102, 87, 88, 91, 87, 74),
  loser = c( 70, 79, 68, 85,  90, 89, 91, 82, 80, 69)
)
head(crayfish_fight_club)
```

Alltså består varje rad av mätningar på två individer där grupperingen är **beroende** på vem de jämförs med, och därför gör vi ett parat t-test. (Det känns inte rimligt att jämföra vinnaren på rad tre (75 cm) med förloraren på rad fyra (85 cm) eftersom de inte stred med varandra, vilket är vad vi hade gjort om vi behandlat data som oberoende, alltså `paired = FALSE`.) Notera att för parad/beroende data måste **differensen** vara normalfördelad.

```{r}
t.test(
  crayfish_fight_club$winner,
  crayfish_fight_club$loser,
  paired = TRUE
)
```

##### Resultat:

Paired t-test, t(9) = 3.5266, p = 0.006448, Signifikant.

#### Wilcox-test (icke parametriskt)

För när data inte uppfyller krav för t-test eller vi vill titta på skillnader i median.

```{r}
#| eval: false
wilcox.test( # Motsvarar vanligt t-test för två grupper
  grupp_1,
  grupp_2
)

wilcox.test( # Med formel
  body_mass_g ~ species,
  data = peng_groups
)
```

```{r}
wilcox.test( # Motsvarar parat t-test för beroende data
  crayfish_fight_club$winner,
  crayfish_fight_club$loser,
  paired = TRUE
)
```

##### Resultat:

Ingen skillnad.

För denna kurs, ignorera `Warning: cannot compute exact p-value with ties`. Det betyder att det finns två av samma mätvärde vilket inte går att rangordna. (Om data är `c(25, 26, 26, 27)` är det `(1,2,3,4)` eller `(1,3,2,4)`?)

#### Bootstrap (icke parametriskt)

För när data inte uppfyller krav för t-test men vi behöver ett konfidensintervall. Resurskrävande, alltså om du har mycket data tar det längre tid att köra funktionen. Ekvivalent med Wilcoxon men ger konfidensintervall.

```{r}
boot.t.test( # Med två vektorer
  grupp_1,
  grupp_2
)
```

```{r}
#| eval: false
boot.t.test( # Med formel
  body_mass_g ~ species,
  data = peng_groups
)
boot.t.test( # Paired/beroende data
  crayfish_fight_club$winner,
  crayfish_fight_club$loser,
  paired = TRUE
)
```

### ANOVA

ANOVA undersöker skillnad mellan många grupper och faktorernas effekt på respons variabeln (liknande regression där kontinuerlig variabel kausalt påverkar respons).

#### Krav/antaganden

Anova är nästan samma som t-test,

-   Data på intervall eller kvotskala (kontinuerlig)

-   Normalfördelad (parametrisk) inom varje grupp (**Bootstrap**)

-   Lika varians (homogen varians, ej för Welch t-test)

-   Inga outliers

-   **Oberoende data** (vi kör inte parat/beroende i denna kurs)

-   **Förutsätter lika varians mellan grupper**

-   **Kan hantera fler än två grupper samt fler än en faktor**

```{r}
# Skapa modellen, sedan diagnostik.
diagnostic_model <- aov(
  body_mass_g ~ species,
  data = penguins
)

par(mfrow = c(1,2))

plot(diagnostic_model, which = 1) # Lika varians om 
# spridningen/"längden" på varje stapel med punkter är lika.

plot(diagnostic_model, which = 2) # QQ-plot för normalfördelning.

par(mfrow = c(1,1))
```

#### Envägs ANOVA

Envägs ANOVA innebär att vi använder en faktor (med flera grupper). Hur hittar man enkelt faktorer och grupper i ett dataset? En faktor är en kolumn med grupper. I `penguins` data frame är `penguins$species` en kolumn med grupper, alltså en faktor.

```{r}
unique(penguins$species) # Unika element i kolumnen,
# alltså, faktorn 'species' har grupperna 'Adelie', 'Gentoo', 'Chinstrap'
```

ANOVA med funktionen `aov()`, `summary()` och `TukeyHSD()`.

```{r}
anova_aov <- aov( # Skapa modell
  body_mass_g ~ species,
  data = penguins
)
summary(anova_aov) # Kolla om det fanns en skillnad mellan någon av grupperna
TukeyHSD(anova_aov) # Kolla mellan vilka grupper det fanns en skillnad

plot(TukeyHSD(anova_aov)) # Plot
```

ANOVA med funktionen `lm()`, `anova()` och `summary()`. Detta ger problem med att göra post-hoc test (`TukeyHSD()`) för att hitta mellan vilka grupper skillnaden finns. Fördelen skulle vara att få ett intercept och möjligen bygga en matematisk modell.

```{r}
anova_lm <- lm( # Skapa modell
  body_mass_g ~ species,
  data = penguins
)
anova(anova_lm) # Kolla om det fanns en skillnad mellan någon av grupperna
summary(anova_lm) # Kolla mellan vilka grupper det fanns en skillnad
```

#### Tvåvägs ANOVA

Samma som envägs ANOVA men med två faktorer. Se [Formel notation].

```{r}
anova2_aov <- aov( # Skapa modell
  body_mass_g ~ species * sex,
  data = penguins
)
summary(anova2_aov) # Kolla om det fanns en skillnad mellan någon av grupperna
TukeyHSD(anova2_aov) # Kolla mellan vilka grupper det fanns en skillnad

plot(TukeyHSD(anova2_aov)) # Plot

# Interaktions plot
interaction.plot(
  x.factor = penguins$sex,         # x-axeln
  trace.factor = penguins$species, # linjerna
  response = penguins$body_mass_g, # y-axeln
)
```

#### Kruskal-Wallis (icke parametrisk)

Icke parametrisk variant av **envägs** ANOVA

```{r}
kruskal.test(
  body_mass_g ~ species,
  data = penguins
)
```

**Detta är utanför kursen!** För att hitta mellan vilka grupper skillnaden finns (post-hoc). Kan inte hantera NA och har krashat R...

```{r}
pairwise.wilcox.test(
  x = penguins$body_mass_g, # Vektor med mätdata
  g = penguins$species,     # 
  p.adjust.method = "holm"
)
```

#### Bootstrap (icke parametriskt)

Om någon av grupperna inte är normalfördelade kan man använda bootstrap. Alla grupper ska fortfarande ha samma varians.

ANOVA.boot() kan inte hantera NA, så se till att filtrera data frame.

```{r}
# Subset to remove NA
peng_boot <- penguins[!is.na(penguins$body_mass_g), ]
peng_boot <- peng_boot[!is.na(peng_boot$species), ]
peng_boot <- peng_boot[!is.na(peng_boot$sex), ]

anova_boot <- ANOVA.boot(
  body_mass_g ~ species * sex,
  data = peng_boot
)
anova_boot[c("terms","df","p-values")]
```

Detta är inte särskillt nice output format så vi undviker helst att använda `ANOVA.boot()`.

## Kontinuerliga samband

### Samvariation/korrelation

När två kontinuerliga variabler ökar/minskar tillsammans (positiv korrelation) eller i motsatt riktning (negativ korrelation), möjligtvis till följd av en gemensam tredje (dold) variabel.

#### Krav/antaganden

-   Två kontinuerliga variabler/mätdata

-   Linjärt samband (kan göras linjär genom transformation om nödvändigt)

```{r}
plot( # Ögonmåtta att sambandet inte är uppenbarligen icke-linjärt
  penguins$flipper_length_mm,
  penguins$body_mass_g
)
```

#### Pearson korrelation

```{r}
plot( # Kolla alltid data
  penguins$flipper_length_mm,
  penguins$body_mass_g
)
cor.test(
  penguins$flipper_length_mm,
  penguins$body_mass_g
)
```

p-värdet tolkas som vanligt, cor är r^2^-värdet som beskriver styrka och riktning av korrelationen.

#### Spearman (icke parametrisk)

```{r}
cor.test(
  penguins$flipper_length_mm,
  penguins$body_mass_g,
  method = "spearman" # Specificera spearman
)
```

För denna kurs, ignorera `Warning: cannot compute exact p-value with ties`. Det betyder att det finns två av samma mätvärde vilket inte går att rangordna. (Om data är `c(25, 26, 26, 27)` är det `(1,2,3,4)` eller `(1,3,2,4)`?)

### Regression

Regression används då en kontinuerlig variabel kausalt orsakar en annan kontinuerlig variabel.

#### Krav/antaganden

-   **Linjärt samband**

-   Normalfördelad (parametrisk)

-   Lika varians

```{r}
par(mfrow = c(1,2))

plot( # Ögonmåtta om det finns en linjär trend.
  x = penguins$flipper_length_mm,
  y = penguins$body_mass_g
)

# Skapa modellen, sedan diagnostik.
diagnostic_model <- aov(
  body_mass_g ~ flipper_length_mm,
  data = penguins
)

plot( # Plot med linjen från modellen som hjälp
  x = penguins$flipper_length_mm,
  y = penguins$body_mass_g
)
abline(diagnostic_model,
       col = "red")

par(mfrow = c(1,1))
```

```{r}
par(mfrow = c(1,2))

plot(diagnostic_model, which = 1) # Lika varians om 
# spridningen av punkter är uniform & röda linjen är platt.

plot(diagnostic_model, which = 2) # QQ-plot för normalfördelning.

par(mfrow = c(1,1))
```

#### Linjär regression

Skapas med en formel liknande för ANOVA.

Med det högst biologiska antagandet att längre fenor orsakar högre kroppsvikt (genom att pingvinerna simmar fortare och därmed kan äta mer, säger vi) enligt en linjär trend, väljer vi att göra linjär regression.

```{r}
plot( # Scatterplot för att kolla sambandet
  penguins$flipper_length_mm,
  penguins$body_mass_g,
  pch = 16,
  cex = 0.4,
  col = "blue",
  xlab = "Flipper length [mm]",
  ylab = "Body mass [g]"
)

mass_by_flipper <- lm( # Skapa model
  body_mass_g ~ flipper_length_mm,
  data = penguins
)
summary(mass_by_flipper)
```

#### Bootstrap

Alternativt med `lm()` och sedan `boot_summary()`.

```{r}
boot.anova_lm <- lm( # Skapa model
  body_mass_g ~ species * sex,   
  data = peng_boot ) 
boot_summary(boot.anova_lm)
```

#### Predict

Om längden på fenorna orsakar kroppsmassa kan vi använda modellen för att förutse vikten på en pingvin baserat på fenornas längd.

Argumentet `newdata = data.frame()` måste innehålla samma kolumn namn som x-axeln och en vektor med de värden på x-axeln man vill förutspå y-värdet för.

```{r}
# Data frame med nya värden att förutspå. 
# Måste ha en kolumn med samma namn som x-axeln i modellen!
measured_flipper_length <- data.frame(
  flipper_length_mm = c(205, 221, 179)
)

# De värden vi gissar med hjälp av modellen
estimated_weight <- predict(
  object = mass_by_flipper, # Modellen
  newdata = measured_flipper_length) # nya x-värden
```

```{r}
plot(
  penguins$flipper_length_mm,
  penguins$body_mass_g,
  
  pch = 16,
  col = alpha("blue", 0.2)
)
points(
  x = measured_flipper_length$flipper_length_mm, # newdata
  y = estimated_weight, # Gissade värden
  
  pch = 16,
  col = "red"
)
abline( # Lägg till linjen från modellen.
  reg = mass_by_flipper,
  col = "red",
  lwd = 1
)
```

## Fördelning av frekvens data

### Chi-square (X^2^-test)

Det enda testet på kursen som hanterar frekvenser/räknedata. Principiellt behövs tre saker, en faktor med grupper som blir kolumner, en faktor med grupper som blir rader, individer/föremål att räkna.

Till ära av Tobbes doktorsavhandling används här data om Gemsbock och Red hartbeest och deras observerade fördelning på fyra områden.

```{r}
bockar <- rbind(
  Gemsbock =      c(FR = 5, CGA = 7, WMA = 12, NP = 67),
  Red_hartbeest = c(     6,       8,       54,      13)
)

bockar
```

#### Krav/antaganden

-   Frekvens data (nominal skala)

-   Väntevärdet/expected i varje cell ska vara minst 5 (Fishers exact test)

```{r}
low_expected <- rbind(
  c(2,3,4),
  c(4,5,6)
)
low_expected_test <- chisq.test(
  low_expected
)
low_expected_test$expected
```

#### Anpassning

Kollar om en rad data "kan anpassas" efter en fördelning, vanligen lika många i varje kategori. Så om data ser ut såhär,

```{r}
bockar["Gemsbock", , drop = FALSE] # Det extra ', drop = FALSE' gör att vi behåller namnet på raden (som annars försvinner mystiskt när matrisen har bara en rad). 
# Detta kan ignoreras och skulle då vara 'bockar["Gemsbock", ]'.

bockar_anpassning <- chisq.test(
  bockar["Gemsbock", ]
)
bockar_anpassning # Visa resultatet
bockar_anpassning$expected # Visa väntevärden
```

Alternativt, anpassning mot en specifik fördelning.

```{r}
bockar_anpassning <- chisq.test(
  bockar["Gemsbock", ],
  p = c(0.10, 0.15, 0.35, 0.40) # Totalt ska dessa bli 1
)
bockar_anpassning # Visa resultatet
bockar_anpassning$expected # Visa väntevärden
```

#### Oberoende

Testa slumpmässiga observationer från två olika faktorer samtidigt för att se om de kommer från samma fördelning. Innebär att alla kolumner och alla rader kan ha olika summor. Så om data ser ut såhär,

```{r}
# Skapa ny kolumn med summan av varje rad
bockar_sums <- cbind(
  bockar,
  Row_sum = rowSums(bockar)
)
# Skapa ny rad med summan av varje kolumn
bockar_sums <- rbind(
  bockar_sums,
  Col_sum = colSums(bockar_sums)
)
bockar_sums
```

Varken alla rader eller alla kolumner har samma summor, alltså gör vi ett oberoende test.

```{r}
bockar_oberoende <- chisq.test(
  bockar
)
bockar_oberoende
bockar_oberoende$expected
```

#### Homogenitet

Testa slumpmässiga observationer från **en** faktor och kontrollera den andra. Innebär att **antingen** alla rader **eller** kolumner har samma summa (medan den andra varierar).

För detta behöver vi ny data. Ett stort företag vill undersöka om antalet vaccinerade anställda skiljer sig mellan avdelningarna. För att kontrollera för de olika avdelningarna slumpades 100 anställda från varje avdelning och frågade om de var vaccinerade eller inte.

```{r}
uppsala_site <- rbind( # Data
  vaccinerad = c(RnD = 99, HR = 45, Lön = 63, IT = 76),
  ej_vaccinerade = c(   1,      55,       37,      24)
)

uppsala_site
```

Vi kan utforska företagets data lite mer genom att lägga till rad och kolumn summor.

```{r}
# Skapa ny kolumn med summan av varje rad
uppsala_sums <- cbind(
  uppsala_site, 
  Row_sum = rowSums(uppsala_site)
)
# Skapa ny rad med summan av varje kolumn
uppsala_sums <- rbind(
  uppsala_sums, 
  Col_sum = colSums(uppsala_sums)
)
uppsala_sums
```

Detta säger oss att den faktorn är kontrollerad, alltså gör vi ett Homogenitetstest.

```{r}
vaccin_homogen <- chisq.test(
  uppsala_site
)

vaccin_homogen
vaccin_homogen$expected
```

### Fisher's exact (icke parametrisk)

Ifall en eller flera celler med väntevärden/expected är \< 5 kan man använda Fisher's exact test.

```{r}
uppsala_fisher <- fisher.test(
  uppsala_site
)

uppsala_fisher # Inga expected values
```

{{< pagebreak >}}

# Matte

## Matematiska beräkningar

```{r}
#| eval: false
1 + 1   # addition
1 - 1   # subtraktion
5 * 4   # multiplikation
6 / 2   # division
5^2     # upphöjt med

sqrt(25)  # roten ur, (positiv)
exp(3)    # e^3
log(7)    # log(7) med basen e
log10(7)  # log(7) med basen 10
```

##### Matriser

```{r}
A <- rbind(
  c(1,2),
  c(3,4)
)
B <- rbind(
  c(5,6),
  c(7,8)
)
C <- rbind(
 c(19,22),
 c(43,50)
)
```

```{r}
A %*% B  # Matrismultiplikation
A %^% 5  # Upphöjt med, kräver att paketet 'expm' är laddat med library()
solve(A, C) # För ekvationen A %*% B = C ger solve(A,C) svaret B
solve(A)    # Med en matris antas A %*% A-invers = I alltså ges A-invers
```

```{r}
eigen_values_vectors <- eigen(A) # Egenvärden och egenvektorer i lista
eigen_value <- eigen_values_vectors$values[1]    # Dominant egenvärde
eigen_vector <- eigen_values_vectors$vectors[,1] # Dess egenvektor
```

## Differensekvationer

Betrakta ekv. $x_{n+2} = 4x_{n}$ med begynnelsevilkor x~0~ = 5; x~1~ = 6.

a.  Hitta en explicit formel

    Detta kan vi inte lösa med R.

b.  Beräkna x~7~

```{r}
x <- c()
x[1] <- 5
x[2] <- 6

for (i in 1:10) {
  x[i+2] <- 0*x[i+1] + 4*x[i]
}
x[7]
```

Alternativt skrivsätt som ger samma sak.

```{r}
x <- c(5,6)

for (i in 3:12) {
  x[i] <- 0*x[i-1] + 4*x[i-2]
}
x[7]
```

## Kritiska punkter

Betrakta funktionen $f(x)=x^2e^{1-x^2}$

a.  Visa att derivatan är $f'(x)=2x(1-x^2)e^{1-x^2}$

    Detta kan vi inte göra (bra) i R.

b.  Bestäm kritiska punkter och avgör deras typ

    Kritiska punkter ges då $f'(x)=0$ så vi definerar funktionerna.

    ```{r}
    f_av_x <- function(x) {  # Funktion av funktion
      x^2*exp(1-x^2)
    }
    f_deriv <- function(x) { # Derivata av funktion
      fderiv(f_av_x, x)
    }
    ```

    Skapar en plot för att grafiskt hitta nollpunktena.

    ```{r}
    plot(  # För att grafiskt hitta intervallen för nollställen
      f_deriv,
      xlim = c(-3,3),
      ylim = c(-2,2),
      col = "red"
    )
    abline(h = 0) # Linje för noll
    abline(v = -2, lty = 2) # Markera nedre intervall
    abline(v = 2, lty = 2)  # Markera övre intervall
    ```

    Använder `uniroot()` för att hitta exakta nollställen.

    ```{r}
    x_1 <- uniroot(f_deriv, 
                   interval = c(-2, -0.5)
                   )$root
    x_2 <- uniroot(f_deriv, 
                   interval = c(-0.5, 0.5)
                   )$root
    x_3 <- uniroot(f_deriv, 
                   interval = c(0.5, 2)
                   )$root

    print(paste("Lösningarna är",x_1,";",x_2,";",x_3))
    ```

    Här måste man tänka till och avgöra om dessa tal egentligen ska avrundas till fina heltal eller omvandlas till bråk.

    Teckentabell används för att avgöra dess typ.

c.  Funktionens största/minsta värde på intervaller \[-2,2\]

    Sätt in x-värden för punkter av intresse och jämför.

d.  Bestäm ekvationen för tangenten till $y=f(x)$ i punkten x = 2

    ```{r}
    x <- 2
    slope <- f_deriv(x)
    intercept <- f_av_x(x) - slope * x

    print(paste("Tangentens ekv. är: f(x) =",slope,"*x +",intercept))
    ```

## Matriser & diagonalisering

Betrakta matrisen $A=\begin{bmatrix} 2 & 1 \\ 1 & 2 \end{bmatrix}$

a.  Bestäm egenvärdena till A

    ```{r}
    A <- rbind(
      c(2,1),
      c(1,2)
    )

    A_eigen <- eigen(A)
    A_eigen$values
    ```

b.  Bestäm egenvektorerna till A

    ```{r}
    A_eigen$vectors
    ```

c.  Diagonalisera A, d.v.s. hitta en diagonalmatris D och en inverterbar matris C, så att $A=CDC^{-1}$

    ```{r}
    D <- rbind(
      c(A_eigen$values[1], 0),
      c(0, A_eigen$values[2])
    )
    C <- rbind(
      c(A_eigen$vectors[1,1], A_eigen$vectors[1,2]),
      c(A_eigen$vectors[2,1], A_eigen$vectors[2,2])
    )
    C_invers <- solve(C)

    C %*% D %*% C_invers # = A

    C_invers %*% A %*% C # = D
    ```

d.  Beräkna A^8^ med hjälp av svaret i c.

    ```{r}
    n <- 8
    C %*% (D %^% n) %*% C_invers # = A %^% n
    ```

## Diskreta dynamiska system

Betrakta det diskreta dynamiska systemet $x_{n+1}=\frac{5x_n^2}{x_n^2+6}$

a.  Bestäm systemets övergångsfunktion

    Övergångs funktion $f(x)=\frac{5x^2}{x^2+6}$

    ```{r}
    discrete_fun <- function(x) {
      (5*x^2)/(x^2+6)
    }
    ```

b.  Bestäm systemets tre jämviktspunkter

    Lös $f(x)=x$ med `uniroot()`

    ```{r}
    discrete_fun_Eq <- function(x) {
      discrete_fun(x) - x
    }
    plot(
      discrete_fun_Eq, 
      ylim = c(-0.5,0.5), 
      xlim = c(-1,5),
      col = "red"
    )
    abline(h = 0)

    x_1 <- uniroot(discrete_fun_Eq, 
                   interval = c(-0.5, 0.5)
                   )$root
    x_2 <- uniroot(discrete_fun_Eq, 
                   interval = c(1.5, 2.5)
                   )$root
    x_3 <- uniroot(discrete_fun_Eq, 
                   interval = c(2.5, 3.5)
                   )$root

    print(paste(x_1,";",x_2,";",x_3))
    ```

    Avgör själv om dessa rötter måste avrundas eller omvandlas till bråk.

c.  Avgör om de är stabila/instabila

    Beroende på om derivatan är större/mindre än ett blir jämviktspunkten ➜ instabil \< 1 \< stabil

    ```{r}
    discrete_deriv <- function(x) {
      fderiv(discrete_fun, x)
    }

    check_stability <- function(x) {
      if (abs(x) > 1) {
        print(paste(x, "är stabil"))
      } else {
        print(paste(x,"är instabil"))
      }
    }

    check_stability(x_1)
    check_stability(x_2)
    check_stability(x_3)
    ```

## Differentialekvationer

```{r}
# Funktion med ekvationssystemet att lösa
DE_fun <- function(times, # Intervall
                   y,     # Begynnelsevärden
                   parms  # Andra värden
) {
  # variabler att använda (från parms)
  alfa <- parms["alfa"]
  beta <- parms["beta"]
  delta <- parms["delta"]
  gamma <- parms["gamma"]
  
  # Begynnelsevärden (från y)
  B <- y["B"]
  P <- y["P"]
  
  # Differentialekvationen att lösa numeriskt
  #   (Minst 1 ekv. men sedan är det bara att lägga till fler ekv.
  #   på var sin rad. Varje ekv. måste ha ett begynnelsevärde &
  #   sedan returneras i result_vec)
  dB <- alfa * B - beta * B * P
  dP <- delta * B * P - gamma * P
  
  # Spara & returnera resultatet (ode() är lite speciell...)
  result_vec <- c( # Först som vektor
    dB,
    dP
  )
  result_list <- list(result_vec) # Sedan som lista
  return(result_list) #Returnera
}

# Vektor med alla tidssteg (t) att sätta in
DE_time_span <- seq(
  from = 0, # Början på intervall
  to = 30,  # Slut på intervall
  by = 0.1  # Steglängd
)

# Vektor med begynnelsevärden 
#   (enklast att namnge dem och sedan indexera med namnet i fun)
DE_init <- c(
  B = 200,
  P = 10
)

# Vektor med andra värden för formeln
#   (enklast att namnge dem och sedan indexera med namnet i fun)
DE_params <- c(
  alfa = 2.5,
  beta = 0.15,
  delta = 0.02,
  gamma = 1.5
)

# Lösa ekvationerna numeriskt
DE_sol <- ode(
  y = DE_init,           # Begynnelsevärden
  times = DE_time_span,  # Intervall
  func = DE_fun,         # Funktionen
  parms = DE_params,     # Andra värden
  method = "rk4"         # Runge-Kutta version 4
)
# Konvertera till data frame för att göra den lättare att hantera
DE_sol <- as.data.frame(DE_sol)


# Plotta dB respektive dP mot tid
plot( # Plot fönster & dB mot tid
  DE_sol$time,
  DE_sol$B,
  type = "l",
  
  col = "blue",
  
  xlab = "Time",
  ylab = "Värde på dIdt & dSdt",
  main = "Numerisk lösning för system av differentialekvationer"
)
lines( # Lägg till dP mot tid
  DE_sol$time,
  DE_sol$P,
  
  col = "darkorange"
)
```

{{< pagebreak >}}

# KvantBio

## Fibonacci

```{r}
n <- c(1,2)
for (i in 3:25) {
  n[i] <- n[i-1] + n[i-2]
}
n
```

## Hantera modeller

Kunna använda modeller och lösa för saknade parametrar. Översätt de matematiska funktionerna till funktioner i R. Funktionen `uniroot()` är användbar för att hitta nollställen.

### Allometri & energiförbrukning

$$
K = P + M + E
$$

Bioenergetisk modell där K = konsumtion, P = produktion/ökning i massa, M = metabolism, E = exkretion.

$$
log_{10}(O_2) = 0.36 \cdot \frac{S}{TL} + 1.945
$$

Modell för citronhajars metabolism baserat på sambandet mellan simhastighet och syreförbrukning (för hajar som väger 1kg).

### Individuell tillväxt (von Bertalanffys tillväxtekvation)

$$
L(t) = L_{\infty} + (L_0 - L_{\infty}) \cdot e^{-kt}
$$

Där L_inf är maxlängd vid oändlig tid, L_noll är längden vid t = 0 , k är en tillväxtfaktor och t är tid/ålder.

För att hitta längden vid givet t.

```{r}
# Parametrar
L_inf <- 85
k <- 0.00082
L_noll <- 30

# Funktion av t
growth_av_t <- function(t) {
  L_t <- L_inf + (L_noll - L_inf) * exp(-k * t)
  return(L_t)
}
growth_av_t(t = 10)
```

För att hitta L_inf (eller annan okänd från funktionen) kan vi möblera om till

$$
0 = L_{\infty} + (L_0 - L_{\infty}) \cdot e^{-kt} - L_t
$$

och använda `uniroot()`.

```{r}
# Parametrar
k <- 0.00082
L_noll <- 30
L_t <- 95
t <- 2000

# Funktion av L_inf
growth_av_L_inf <- function(L_inf) {
  noll_punkt <- L_inf + (L_noll - L_inf) * exp(-k * t) - L_t
  return(noll_punkt)
}

# Hitta nollpunkten med uniroot()
uniroot(
  f = growth_av_L_inf,
  interval = c(0,200)
)$root
```

## Hållbart uttag

Hur tillväxer en population och vid vilken storlek kan man plocka ut så många individer som möjligt och samtidigt få en stabil population?

```{r}
# Rekryteringsfunktion, n individer detta år ger n+x individer nästa år
recruitment <- function(n) {
  recruit <- 2.17 * sqrt(n) * log(n+1)
  return(recruit)
}
# Plot
curve(
  recruitment,
  xlim = c(0,120),
  col = "blue",
  xlab = "pop. detta tidssteg",
  ylab = "pop. nästa tidssteg"
)
curve(
  1*x,
  add = TRUE,
  col = "darkorange"
)
```

```{r}
# Skördekurva
harvest <- function(n) {
  harvest <- recruitment(n) - n
  return(harvest)
}

# Plot
curve(
  harvest,
  xlim = c(0,120),
  xlab = "pop. detta tidssteg",
  ylab = "Hållbart uttag",
  col = "darkgreen"
)
abline(
  h = 0
)
```

```{r}
#| warning: false
# Hitta x-värde för maxpunkt, alltså pop. storlek för max hållbart uttag.

# Derivata av skördefunktionen
harvest_deriv <- function(n) {
  harvest_deriv <- fderiv(harvest, n)
  return(harvest_deriv)
}

# Plot (indikerar intervallet för uniroot())
curve(
  harvest_deriv,
  xlim = c(0,120),
  xlab = "pop. detta tidssteg",
  ylab = "Skördefunktionens derivata",
  col = "purple"
)
abline(
  h = 0
)

# Hitta nollpunk numeriskt = pop. storlek för max hållbart uttag
harvest_deriv_root <- uniroot(
  harvest_deriv,
  interval = c(20,60)
)
```

```{r}
# Insättning av nollpunkt i skördefunktion ger max hållbart uttag
harvest(harvest_deriv_root$root)
```

## Diskret logistisk tillväxt

$$
x_{n+1} = x_n + r \cdot x_n \cdot (1- \frac{x_n}{k})
$$

Funktion för diskret logistisk tillväxt.

```{r}
dlt <- function(n, r, k) {
  n_ny <- n + r*n*(1-n/k)
  return(n_ny)
}
```

### Modellera en population

Definiera värden på parametrar.

```{r}
r <- 0.36 # perkapitareproduktion (egenvärde från Leslie-matris)
k <- 600  # Bärkraft

sluttid <- 30
t <- 1:(sluttid+1)
```

En populationsutveckling med konstant r-värde.

```{r}
n <- c(4) # Startvärde & vektor att lagra resultat i

for (i in 1:sluttid) { # Loop för pop. utveckling
  n[i+1] <- dlt(n = n[i],
                r = r,
                k = k)
}

plot(
  x = t,
  y = n,
  ylim = c(0,k),
  
  type = "l",
  lwd = 2,
  
  xlab = "Time",
  ylab = "Individer"
)
```

Samma, men med varierande r-värde.

```{r}
# r <- 0.36 # perkapitareproduktion (egenvärde från Leslie-matris)
k <- 600  # Bärkraft

sluttid <- 30
t <- 1:(sluttid+1)

n <- c(4) # Startvärde & vektor att lagra resultat i

for (i in 1:sluttid) { # Loop för pop. utveckling
  n[i+1] <- dlt(n = n[i],
                r = rnorm(n = 1,
                          mean = 0.36,
                          sd = 0.2),
                k = k)
}

plot(
  x = t,
  y = n,
  ylim = c(0,k),
  
  type = "l",
  lwd = 2,
  
  xlab = "Time",
  ylab = "Individer"
)
```

### Modellera många populationer & beräkna utdöende risk

Definiera värden på parametrar.

```{r}
# r defineras i for-loop
k <- 1000 # Bärkraft

sluttid <- 20
t <- 1:(sluttid+1)

collapse <- 10 # Färre individer = pop. dör ut
```

Skapa många linjer för hypotetiska populationers öden.

```{r}
plot( # Skapa tom plot
  NULL,
  xlim = c(0, sluttid+1),
  ylim = c(0, 200),
  type = "l",
  xlab = "Time",
  ylab = "Individer"
)

n <- c(50) # Startvärde & vektor att lagra resultat i
pop_collapse <- 0 # Räknare för hur många populationer har dött ut
attempts <- 10

for (i in 1:attempts) { # Loop för upprepade försök/linjer
  
  for (j in 1:sluttid) { # Loop för en linje/population
    n[j+1] <- dlt(n = n[j],
                  r = rnorm(n = 1, # slumpad reproduktion
                            mean = 0,
                            sd = 0.25),
                  k = k)
  }
  
  if (min(n) < collapse) { # Kolla om pop. collapsade
    pop_collapse <- pop_collapse +1 # Addera 1 till räknare
    print(paste("Försök",i,"dog ut. Totalt",pop_collapse,"collapsade populationer."))
  }
  
  lines( # Addera linje för ett försök
    x = t,
    y = n,
    lwd = 1,
    col = "blue"
  )
  
}
```

För att beräkna utdöenderisk i procent.

```{r}
extiction_rate <- (pop_collapse / attempts) *100
print(paste("Utdöenderisken är",extiction_rate,"%"))
```

## Lesliematriser

För användning av en livstabell översätts den till en Leslie/Lefkovitch matris.

![](Livstabell%20caretta%20caretta.png)

En Leslie-matris använder åldersklasser där ingen kan "stanna" i klassen, alltså är diagonalen 0.

En Lefkovitch-matris använder ontogenetiska stadier där en individ kan antingen "stanna" i samma klass eller "gå vidare" till nästa klass, alltså kan diagonalen vara \>0.

![](Leslie-Lefkovitch%20matte.png)

![](Leslie-Lefkovitch%20förklaring.png)

```{r}
caretta_matris <- rbind( # En Lefkovitch matris
  r1 = c(c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 127, c6 = 4, c7 = 80),
  r2 = c(0.6747,  0.737,      0,      0,        0,      0,       0),
  r3 = c(     0, 0.0486,  0.661,      0,        0,      0,       0),
  r4 = c(     0,      0, 0.0147, 0.6907,        0,      0,       0),
  r5 = c(     0,      0,      0, 0.0518,        0,      0,       0),
  r6 = c(     0,      0,      0,      0,   0.8091,      0,       0),
  r7 = c(     0,      0,      0,      0,        0, 0.8091,  0.8091)
)
caretta_matris
```

För att få ut egenvärdet (r-värdet) och egenvektorn (stabil stadiefördelning). Om $\lambda$ är 0.90 innebär det att populationen minskar med 10% (förändrings faktor för populationen). Den relativa fördelningen ($\frac{egenvektor}{sum(egenvektor)} \cdot 100$ ) indikerar hur många procent av den totala populationen bör finnas i varje klass. Kan användas som `p = relativ_dist` i `chisq.test()` för att göra ett anpassningstest med en observerad population.

```{r}
caretta_eigen <- eigen(caretta_matris)

# Egentligen det största egenvärdet, men det bör vara första.
Re(caretta_eigen$values[1])

# Samma index för egenvektor som egenvärdet.
Re(caretta_eigen$vectors[,1])

# Relativ fördelning i procent
caretta_dist <- Re(caretta_eigen$vectors[,1])
caretta_dist_procent <- (caretta_dist/sum(caretta_dist))*100
caretta_dist_procent
```

## Lotka-Volterra byte-predator modell

En specifik model som bygger på att lösa ett ekvationssystem av differentialekvationer.

![](lotka-volterra.PNG)

```{r}
# Funktion med ekvationssystemet att lösa
LV_fun <- function(times, # Intervall
                   y,     # Begynnelsevärden
                   parms  # Andra värden
) {
  # variabler att använda (från parms)
  alfa <- parms["alfa"]
  beta <- parms["beta"]
  delta <- parms["delta"]
  gamma <- parms["gamma"]
#  K <- parms["K"] # alt. där K = bärkraft
  
  # Begynnelsevärden (från y)
  B <- y["B"]
  P <- y["P"]
  
  # Differentialekvationen att lösa numeriskt
  dBdt <- (alfa * B - beta * B * P)
#  dBdt <- (alpha * B(1 - B/K) - beta * B * P) # alt. där K = bärkraft
  
  dPdt <- (delta * B * P - gamma * P)
  
  # Spara & returnera resultatet
  result_vec <- c(
    dBdt,
    dPdt
  )
  result_list <- list(result_vec)
  return(result_list)
}

# Vektor med alla tidssteg (t) att sätta in
time_span_LV <- seq(
  0,
  30,
  by = 0.1
)

# Vektor med begynnelsevärden
init_LV <- c(
  B = 200,
  P = 10
)

# Vektor med andra värden för formeln
params_LV <- c(
  alfa = 2.5,    # Tillväxt byten
  beta = 0.15,   # Byten som äts
  delta = 0.02,  # Tillväxt predator
  gamma = 1.5    # Död predator
#  K = 500 # alt. där K = bärkraft
)

# Lösa ekvationerna numeriskt
sol_LV <- ode(
  y = init_LV,           # Begynnelsevärden
  times = time_span_LV,  # Intervall
  func = LV_fun,         # Funktionen
  parms = params_LV,     # Andra värden
  method = "rk4"         # Runge-Kutta version 4
)
sol_LV <- as.data.frame(sol_LV)
```

Plotta grafen.

```{r}
# Plotta antal insekter [milljoner] respektive spindlar [tusen] mot tid
plot(
  sol_LV$time,
  sol_LV$B,
  type = "l",
  
  col = "blue",
  
  xlab = "Time",
  ylab = "Number of individuals",
  main = "Lotka-Volterra model"
)
lines(
  sol_LV$time,
  sol_LV$P,
  
  col = "darkorange"
)
legend(
  "topright",
  legend = c("Byten", 
             "Predatorer"),
  
  lty = c(1, 1),
  col = c("blue",
          "darkorange")
)


# "Fasporträtt" (två pop. mot varandra där tiden blir att följa linjen)
plot(
  sol_LV$B,
  sol_LV$P,
  type = "l",
  
  col = "darkgreen",
  
  xlab = "Byten",
  ylab = "Predatorer",
  main = "Fasporträtt"
)
```
