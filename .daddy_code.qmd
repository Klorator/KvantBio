---
title: ".daddy_code"
author: "Rasmus Hammar"
format:
  pdf:
    highlight-style: atom-one
    toc: true
    number-sections: true
  html: 
    highlight-style: atom-one
    toc: true
    number-sections: true
    embed-resources: true
    self-contained-math: true
    code-overflow: wrap
include-in-header: 
  text: |
    \usepackage{fvextra}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
editor: visual
execute: 
  echo: true
---

{{< pagebreak >}}

# Allmänt

Lite allmänna funktioner som är bra att kunna.

## Paket & inläsning av data

För att installera ett paket.

```{r}
#| eval: false
# För att installera paketet som heter palmerpenguins
install.packages("palmerpenguins")

# Stats
install.packages("MKinfer")
install.packages("lmboot")
install.packages("boot.pval")

# Matte
install.packages("pracma")
install.packages("expm")
install.packages("deSolve")

# KvantBio
install.packages("plotrix")
install.packages("scales")
```

För att använda funktioner i ett paket måste man ladda in paketet i R genom `library()`

```{r}
#| output: false
#| warning: false
# Exempel data
library(palmerpenguins)

# Stats
library(MKinfer)
library(lmboot)
library(boot.pval)

# Matte
library(pracma)
library(expm)
library(deSolve)

# KvantBio
library(plotrix)
library(scales)
```

För att läsa in data från t.ex. en .csv eller .txt fil. Öppna filen och identifiera vilka symboler som **sep**arerar kolumner samt används som **dec**imaltecken.

```{r}
#| eval: false
file.choose() # Returnerar vägen till filen man väljer, hitta fönstret med alt + tab.

my_data <- read.table(
  file = file.choose(), # Välj fil interaktivt, alt. filens sökväg som en text string
  header = TRUE, # Om det finns namn på kolumnerna
  sep = ",", # Här används ett kommatecken för att skilja på kolumner
  dec = "." # Här används en punkt som decimaltecken
)
```

För att titta på data kan man använda

```{r}
# View(penguins) # Öppnar som separat flik
head(penguins, # Printar de första n raderna
     n = 3)
tail(penguins, # Printar de sista n raderna
     n = 3)
```

För att skapa olika datastrukturer

## Variabel

```{r}
var_1 <- "Text/character string" # Någonting inuti "" är text
var_2 <- 25 # Nummer, för decimaltal 25.99
var_3 <- TRUE # Boolean, kan bara vara TRUE (T) eller FALSE (F)
var_4 <- NA # Not Available (NA), inte samma som "NA" (text string)!
var_5 <- NULL # Ingenting, tenderar att radera saker!
```

## Vektor

```{r}
vec_1 <- c() # Skapar en tom vektor
vec_1 <- c(36, 56, 48) # Skapa en vektor med tre värden
vec_1[4] <- 25 # Sätta in ett värde i index plats 4
vec_1 # Printa innehållet av variablen (vektorn)
```

```{r}
#| eval: false
vec_1[2] # Printa innehållet i index 2
```

```{r}
#| eval: false
vec_1[c(1,3)] # Printa index 1 och 3
```

Vektorer kan innehålla namn och indexeras med namn

```{r}
vec_2 <- c(element_1 = 99, element_2 = 100, element_3 = 101)
vec_2["element_4"] <- 102 # Sätt in ett värde med namn
vec_2
```

```{r}
#| eval: false
vec_2["element_2"]
```

```{r}
#| eval: false
vec_2[c("element_1", "element_3")]
```

## Data frame

```{r}
df <- data.frame( # Skapa en dataframe med kolumn_namn = vektor
  vec_1, # Kolumn 1, vec_1 från tidigare
  letters = LETTERS[1:4] # Kolumn 2, lite bokstäver
)
df
```

Man kan lägga till kolumner med \$

```{r}
df$col_3 <- vec_2 # Kolumn 3
df
```

Andra sätt att lägga till kolumner är med namn

```{r}
df["col4"] <- letters[1:4]
df
```

En kolumn kan användas med \$ vilket ger en vektor (viktig distinktion vid vissa andra tillfällen).

```{r}
#| eval: false
df$letters # Ger en vektor, samma som med df[["letters]]
```

Eller med indexering/namn, N.B. enkla `[ ]` ger ett subset, alltså en mindre del av samma objekt typ

```{r}
#| eval: false
df[3] # Ger en data frame med enbart kolumn 3
df["col4"] # Ger en data frame med kolumn "col4"
```

medan dubbla `[[ ]]` ger objektet inuti

```{r}
#| eval: false
df[[1]] # Ger det "mindre objektet inuti", alltså en vektor i detta fall
```

Enkla `[ ]` kan indexeras med rader och kolumner samtidigt

```{r}
#| eval: false
df[2] # Kolumn 2 (en data frame med en kolumn)
df[3,2] # Rad 3, kolumn 2 (en vektor av längd ett)
df[ ,2] # Alla rader, kolumn 2 (en vektor)
df[3, ] # Rad 3, alla kolumner (en data frame med en rad)
```

På tal om subsetting, för att ta ett subset av en data frame kan man filtrera rader baserat på ett kriterium

```{r}
penguins_chin <- penguins[penguins$species == "Chinstrap", ] 
# Utan komma läses det som att du vill filtrera kolumner! '==' är det matematiska 'lika med' (eftersom '=' är samma som '<-' )
head(penguins_chin, 3)

penguins_heavy <- penguins[penguins$body_mass_g > 3500, ]
head(penguins_heavy, 3)
```

Man kan även göra detta för att få en kolumn filtrerad/subset baserad på en annan kolumn.

```{r}
#| eval: false
penguins_chin_weight <- penguins$body_mass_g[penguins$species == "Chinstrap", ]
```

`Error in penguins$body_mass_g[penguins$species == "Chinstrap", ] :    incorrect number of dimensions`

Det blir en error därför att nu försöker man ta både rader och kolumner (2 dimensioner) på en kolumn (kolumn/vektor har bara 1 dimension) därför att \$ ger en vektor. Om vi istället provar utan extra kommatecken för att ange rader & kolumner samtidigt fungerar det (ger en vektor). Alternativt ange kolumnen med namn istället för med \$ (ger en mindre data frame).

```{r}
# Utan extra kommatecken
penguins_chin_weight <- penguins$body_mass_g[penguins$species == "Chinstrap"]
head(penguins_chin_weight)

# Ange kolumnen med namn
penguins_chin_weight <- penguins[penguins$species == "Chinstrap", "body_mass_g"]
head(penguins_chin_weight)
```

Vi kan även bli av med `NA` på ett kontrollerat sätt med den här metoden. Om man vill se till att vikt och näbblängd inte har `NA` kan man använda funtionen `in.na()` och operatorn `!`.

```{r}
is.na(NA) # Kolla om NA är NA
!is.na(NA) # ! negerar ett TRUE/FALSE uttryck

vec_NA <- c(NA, 50)
is.na(vec_NA) # Kolla vilka element som är NA
!is.na(vec_NA)
```

```{r}
# Alla rader där kolumnen body_mass_g inte är NA och alla kolumner
penguins_no_NA <- penguins[!is.na(penguins$body_mass_g), ]
# Alla rader där kolumnen bill_length_mm inte är NA och alla kolumner
penguins_no_NA <- penguins_no_NA[!is.na(penguins_no_NA$bill_length_mm), ]

# Tabell med antal rader & kolumner
data.frame(
  rows = c(penguins = nrow(penguins), no_NA = nrow(penguins_no_NA)),
  columns = c(penguins = ncol(penguins), no_NA = ncol(penguins_no_NA))
)
```

## Matris

Vi kan skapa matriser med `rbind()` (går även att använda `cbind()` men då placeras vektorerna vertikalt från det övre vänstra hörnet, istället för horisontellt). Med `rbind()` blir matrisen som den ser ut när man skriver den.

```{r}
rbind( # en "character matrix"
  c("a", "b"),
  c("c", "d")
)

cbind( # skillnaden med cbind()
  c("a", "b"),
  c("c", "d")
)

M <- rbind( # Skapar en matris radvis med namngivna rader och kolumner
  r1 = c(col1 = 0.90, col2 = 0, col3 = 0, col4 = 0, col5 = 0.45),
  r2 = c(          0,     0.45,        0,        0,           0),
  r3 = c(          0,     0.23,     0.45,        0,           0),
  r4 = c(          0,        0,     0.23,     0.45,           0),
  r5 = c(          0,        0,        0,     0.23,        0.20)
)
M
```

För matris matte se [Matte] sektionen.

Matriser kan indexeras ungefär på samma sätt som data frames.

```{r}
#| eval: false
M[3, 2]
M[3:5, 2:3]
M[c(3,5), c(2,3)]
M[c("r3","r5"), c("col2","col3")]
```

## Lista (den riktiga listan)

I en vektor **måste** alla element vara av samma typ (numerisk/text osv.) och i en data frame **måste** alla kolumner (som är vektorer) vara lika långa.

Listor kan ha olika typer av objekt i sig och brukar användas för att bunta ihop olika objekt man vill hålla tillsammans. Till exempel är output från `t.test()` en lista.

```{r}
my_list <- list() # En tom lista
my_list$df_1 <- df # Lägg till en data frame med $
my_list[[2]] <- var_2 # Lägg till en variabel med index, N.B. [[]]
my_list[["plats_3"]] <- vec_2 # Lägg till en vektor med namn, N.B. [[]]
my_list
```

Och man få ut objekten i en lista på samma sätt.

## Lite andra funktioner

Ett objekts typ heter "klass" och kan kollas med funktionen `class()`

```{r}
#| eval: false
class(var_1) # var_1 är text
class(var_2) # var_2 är numerisk
class(var_3) # var_3 är logical/boolean (TRUE/FALSE)
class(vec_1) # vec_1 är numerisk vektor
class(df) # df är en data frame
class(M) # M är en matris
class(my_list) # my_list är en lista
```

För att se till att någonting skrivs i konsollfönstret används `print()`

```{r}
print(var_1) # Tar enbart ett objekt! Se paste()

```

För att skriva ihop text m.m. används `paste()`, den tar dock enbart enskilda element (inte vektor/data frame/list

```{r}
message <- paste(
  "Hello", "world", var_1, 55, vec_2[3], # Alla objekt man vill skriva ihop
  sep = " " # Separator att infoga mellan varje objekt, här ett mellanslag
)
print(message)
```

Notera att `print()` enbart accepterar ett objekt, därav den vanliga kombinationen `print(paste(arg1, arg2))`.

```{r}
print(paste("Nu","klarar","vi","tentan!", sep = "! "))
```

Kolla längden på saker med

```{r}
#| eval: false
length(vec_1) # Längden på en vektor
length(penguins) # Längden på en data frame är antalet kolumner
nrow(penguins) # För antalet rader i en data frame
ncol(penguins) # Antalet columner på en data frame
```

Få en vektor med namnen på kolumner

```{r}
colnames(penguins)
```

Få alla unika element i en vektor

```{r}
unique(penguins$species)
```

## Kontrollstrukturer

Kontrollstrukturer är några speciella funktioner som möjliggör mer kontroll över vilka rader med kod som ska köras.

### Loop

För att köra några rader kod flera gånger används loopar. Detta är exempel på for-loop.

```{r}
vector <- c("Nu", "klarar", "vi", "tentan!")
for (variable in vector) {
  print(variable)
}

for (i in 1:4) {
  print(paste(i, ":", vector[i]))
}

n <- c()
n[1] <- 55
for (i in 1:5) {
  n[i+1] <- i
}
n
```

### If-else

För att köra vissa rader enbart om ett visst kriterium uppfylls används if-else kombination. Resultatet av att "köra koden" i parantesen ska bli `TRUE` för att köra den följande koden.

```{r}
if ("Tenta!" == "Tenta!") { # Blir TRUE
  print(TRUE)
} else {
  print(FALSE)
}

if (5^2 < 100) { # Blir TRUE
  print("Smaller")
} else {
  print("Bigger")
}

if (50^2 < 100) { # Blir FALSE
  print("Smaller")
} else {
  print("Bigger")
}

```

## Plotting

Error plot med `plotCI()`

{{< pagebreak >}}

# Stats

### Tolkning av p-värde

Drivna över bristningsgränsen av kursen har en student blivit galen och vandrar, med slö blick, vilset i stadsskogen. Studenten betraktar ett träd. Hur högt är trädet? Vilsen betraktar studenten ett annat träd och stapplar vidare. Vad är sannolikheten att genomsnittshöjden på de träd studenten slumpmässigt observerar skiljer sig från genomsnittshöjden på alla träd i stadsskogen? Kanske de skiljer sig från träden i fjällen?

-   **H~0~** = Ingen skillnad mellan medelvärden

-   **H~1~** = Skillnad mellan medelvärden

p-värdet är sannolikheten att en stackars vilsen student slumpmässigt skulle betrakta dessa träd och konstatera att deras höjd skiljer sig från resten av skogens (alltså acceptera **H~1~**), när det i verkligheten inte finns någon skillnad mellan observerade och skogens medelvärden (alltså om **H~0~** är sann).

-   Om p-värde \> alfa, alltså p \> 0.05, säger vi att det inte finns en skillnad (acceptera **H~0~**).

-   Om p-värde \< alfa, alltså p \< 0.05, säger vi att det finns en skillnad (acceptera **H~1~**).

### Rapportera test

Rapportera alltid testets namn, statistiken (t.ex. t-/F-värdet), frihetsgrader och p-värde, samt en mening som ger slutsatsen/tolkningen av testet. Andra relevanta saker kan också inkluderas, såsom konfidens intervall.

Exempel: Förklarande mening (\[testets namn\], t(\[frihetsgrader\]) = \[värdet\], p = \[värdet\]).

> Det fanns en skillnad mellan Grupp 1 och den förväntade vikten (mu = 3000 g) enligt internet (One sample t-test, t(150) = 18.776, p \< 2.2e-16).

Tips från coachen, gör detta snyggare än jag...

### Formel notation

Många av funktionerna för de statistiska testen kan, eller måste, ges en formel. Formler har följande komponenter:

-   *Respons*, en kontinuerlig variabel vi vill förutspå, värdet på y-axeln

-   *Faktor*, en kategorisk variabel vilken delar in *Respons* i grupper (för regression är detta en kontinuerlig variabel som direkt orsakar *Respons*)

-   '\~', skiljer *Respons* från *Faktor*, alltså ger Vänster- och Högerled (`Respons ~ Faktor`)

-   '+', adderar en ytterligare *Faktor* (`Respons ~ Faktor_1 + Faktor_2`)

-   '\*', adderar en ytterligare *Faktor* **och** interaktionen (`Respons ~ Faktor_1 * Faktor_2` )

-   ':', adderar enbart interaktionen (`Respons ~ Faktor_1:Faktor_2`)

{{< pagebreak >}}

### Beslutsschema

![Stats flowchart 1](Beslutsschema-1.png)

{{< pagebreak >}}

![Stats flowchart 2](Beslutsschema-2.png)

{{< pagebreak >}}

![Stats flowchart 3](Beslutsschema-3.png)

{{< pagebreak >}}

![Stats flowchart 4](Beslutsschema-4.png)

{{< pagebreak >}}

## Binomial fördelning

Min binomiala studie:

-   20 försök

-   varje försök är Ja/Nej

-   37 % sannolikhet för Ja för varje oberoende försök

För att beräkna sannolikheten för utfall med binomial fördelning används `dbinom()` för att beräkna sannolikheten för exakt x antal gynsamma utfall,

```{r}
f5 <- dbinom(
  x = 5, # Exakt antal 'Ja'
  size = 20, # Totalt antal försök
  prob = 0.37 # Sannolikheten för försöket
)
print(paste("Sannolikhet att exakt fem av 20 försök blir 'Ja':", f5))
```

Dessa sannolikheter kan adderas.

```{r}
f6 <- dbinom(
  x = 6, # Exakt 6st Ja
  size = 20,
  prob = 0.37
)
print(paste("p att exakt 5-6st av 20 försök blir 'Ja':", (f5+f6)))
```

eller `1 - pbinom()` för att beräkna sannolikheten för alla utfall **över** det man anger.

```{r}
f15_20 <- (1 - pbinom(
  q = 14, # utfall över det angivna
  size = 20,
  prob = 0.37
))
print(paste("p att få 15 eller fler 'Ja':",f15_20))
```

Enbart `pbinom()` ger den motsatta sannolikheten (alltså 0-14 Ja) vilket är kompliment till 15-20 Ja. Använd `lower.tail = FALSE` för att få 15-20 Ja istället.

```{r}
f15_20_igen <- pbinom(
  q = 14,
  size = 20,
  prob = 0.37,
  lower.tail = FALSE # Istället för 1 - pbinom()
)
print(paste("p att få 15 eller fler 'Ja':",f15_20_igen))
```

## Skillnad mellan grupper

### T-test

#### Krav/antaganden

-   Data på intervall eller kvotskala (kontinuerlig)

-   Normalfördelad (parametrisk) inom varje grupp

-   Lika varians (homogen varians, ej för Welch t-test)

-   Inga outliers

#### Ensidigt

För att testa om en grupp med kontinuerlig data skiljer sig från ett känt eller teoretiskt väntevärde.

```{r}
grupp_1 <- penguins$body_mass_g[penguins$species == "Adelie"]

t.test(
  x = grupp_1, # En vektor
  mu = 3000    # Väntevärdet vi hittade på internet
)
```

##### Resultat:

Det fanns en skillnad mellan Grupp 1 och den förväntade vikten enligt internet (One sample t-test, t(150) = 18.776, p \< 2.2e-16).

#### Tvåsidigt

För att testa om det finns en skillnad mellan två grupper av kontinuerlig data.

```{r}
grupp_1 <- penguins$body_mass_g[penguins$species == "Adelie"]
grupp_2 <- penguins$body_mass_g[penguins$species == "Gentoo"]

t.test(
  x = grupp_1, # En vektor
  y = grupp_2, # En annan vektor
)
```

Alternativt sätt att skriva koden är med formel.

```{r}
peng_groups <- penguins[ which(penguins$species == "Adelie" | penguins$species == "Gentoo"), ]

t.test( # Respons = mätdata & Faktor = två olika arter (alltså två grupper)
  body_mass_g ~ species,
  data = peng_groups
)
```

##### Resultat:

Det fanns en skillnad mellan Grupp 1 och Grupp 2 (Welch two sample t-test, t(249.64) = -23.386, p \< 2.2e-16).

#### Paired/beroende

First rule of Crayfish Fight Club is you do not talk about Crayfish Fight Club.

Vi studerar kräftor och vill undersöka vilken effekt storleken på klorna har på vilken kräfta som vinner strider om resurser. För att göra detta snorklar vi någonstans tropiskt och letar efter kräftor som slåss. Efter några månader "hårt arbete" har vi samlat ihop följande data. Varje rad är storleken på klorna i cm med vinnare och förlorare i respektive kolumn.

```{r}
crayfish_fight_club <- data.frame(
  winner = c(86, 84, 75, 93, 102, 87, 88, 91, 87, 74),
  loser = c( 70, 79, 68, 85,  90, 89, 91, 82, 80, 69)
)
head(crayfish_fight_club)
```

Alltså består varje rad av mätningar på två individer där grupperingen är **beroende** på vem de jämförs med, och därför gör vi ett parat t-test. (Det känns inte rimligt att jämföra vinnaren på rad tre (75 cm) med förloraren på rad fyra (85 cm) eftersom de inte stred med varandra, vilket är vad vi hade gjort om vi behandlat data som oberoende, alltså `paired = FALSE`.)

```{r}
t.test(
  crayfish_fight_club$winner,
  crayfish_fight_club$loser,
  paired = TRUE
)
```

##### Resultat:

Paired t-test, t(9) = 3.5266, p = 0.006448, Signifikant.

#### Wilcox-test (icke parametriskt)

För när data inte uppfyller krav för t-test eller vi vill titta på skillnader i median.

```{r}
#| eval: false
wilcox.test( # Motsvarar vanligt t-test för två grupper
  grupp_1,
  grupp_2
)

wilcox.test( # Med formel
  body_mass_g ~ species,
  data = peng_groups
)
```

```{r}
wilcox.test( # Motsvarar parat t-test för beroende data
  crayfish_fight_club$winner,
  crayfish_fight_club$loser,
  paired = TRUE
)
```

##### Resultat:

Ingen skillnad.

För denna kurs, ignorera `Warning: cannot compute exact p-value with ties`. Det betyder att det finns två av samma mätvärde vilket inte går att rangordna. (Om data är `c(25, 26, 26, 27)` är det `(1,2,3,4)` eller `(1,3,2,4)`?)

#### Bootstrap (icke parametriskt)

För när data inte uppfyller krav för t-test men vi behöver ett konfidensintervall. Resurskrävande, alltså om du har mycket data tar det längre tid att köra funktionen. Ekvivalent med Wilcoxon men ger konfidensintervall.

```{r}
boot.t.test( # Med två vektorer
  grupp_1,
  grupp_2
)
```

```{r}
#| eval: false
boot.t.test( # Med formel
  body_mass_g ~ species,
  data = peng_groups
)
boot.t.test( # Paired/beroende data
  crayfish_fight_club$winner,
  crayfish_fight_club$loser,
  paired = TRUE
)
```

### ANOVA

ANOVA undersöker skillnad mellan många grupper och faktorernas effekt på respons variabeln (liknande regression där kontinuerlig variabel kausalt påverkar respons).

#### Krav/antaganden

Anova är nästan samma som t-test,

-   Data på intervall eller kvotskala (kontinuerlig)

-   Normalfördelad (parametrisk) inom varje grupp (**Bootstrap**)

-   Lika varians (homogen varians, ej för Welch t-test)

-   Inga outliers

-   **Oberoende data** (vi kör inte parat/beroende i denna kurs)

-   **Förutsätter lika varians mellan grupper**

-   **Kan hantera fler än två grupper samt fler än en faktor**

#### Envägs ANOVA

Envägs ANOVA innebär att vi använder en faktor (med flera grupper). Hur hittar man enkelt faktorer och grupper i ett dataset? En faktor är en kolumn med grupper. I `penguins` data frame är `penguins$species` en kolumn med grupper, alltså en faktor.

```{r}
unique(penguins$species) # Unika element i kolumnen,
# alltså, faktorn 'species' har grupperna 'Adelie', 'Gentoo', 'Chinstrap'
```

ANOVA med funktionen `aov()`, `summary()` och `TukeyHSD()`.

```{r}
anova_aov <- aov( # Skapa modell
  body_mass_g ~ species,
  data = penguins
)
summary(anova_aov) # Kolla om det fanns en skillnad mellan någon av grupperna
TukeyHSD(anova_aov) # Kolla mellan vilka grupper det fanns en skillnad

plot(TukeyHSD(anova_aov)) # Plot
```

ANOVA med funktionen `lm()`, `anova()` och `summary()`. Detta ger problem med att göra post-hoc test (`TukeyHSD()`) för att hitta mellan vilka grupper skillnaden finns. Fördelen skulle vara att få ett intercept och möjligen bygga en matematisk modell.

```{r}
anova_lm <- lm( # Skapa modell
  body_mass_g ~ species,
  data = penguins
)
anova(anova_lm) # Kolla om det fanns en skillnad mellan någon av grupperna
summary(anova_lm) # Kolla mellan vilka grupper det fanns en skillnad
```

#### Tvåvägs ANOVA

Samma som envägs ANOVA men med två faktorer. Se [Formel notation].

```{r}
anova2_aov <- aov( # Skapa modell
  body_mass_g ~ species * sex,
  data = penguins
)
summary(anova2_aov) # Kolla om det fanns en skillnad mellan någon av grupperna
TukeyHSD(anova2_aov) # Kolla mellan vilka grupper det fanns en skillnad

plot(TukeyHSD(anova2_aov)) # Plot
```

#### Kruskal-Wallis (icke parametrisk)

Icke parametrisk variant av **envägs** ANOVA

```{r}
kruskal.test(
  body_mass_g ~ species,
  data = penguins
)
```

**Detta är utanför kursen!** För att hitta mellan vilka grupper skillnaden finns (post-hoc). Kan inte hantera NA och har krashat R...

```{r}
pairwise.wilcox.test(
  x = penguins$body_mass_g, # Vektor med mätdata
  g = penguins$species,     # 
  p.adjust.method = "holm"
)
```

#### Bootstrap (icke parametriskt)

Om någon av grupperna inte är normalfördelade kan man använda bootstrap. Alla grupper ska fortfarande ha samma varians.

ANOVA.boot() kan inte hantera NA, så se till att filtrera data frame.

```{r}
# Subset to remove NA
peng_boot <- penguins[!is.na(penguins$body_mass_g), ]
peng_boot <- peng_boot[!is.na(peng_boot$species), ]
peng_boot <- peng_boot[!is.na(peng_boot$sex), ]

anova_boot <- ANOVA.boot(
  body_mass_g ~ species * sex,
  data = peng_boot
)
anova_boot[c("terms","df","p-values")]
```

Detta är inte särskillt nice output format så vi undviker helst att använda `ANOVA.boot()`.

## Samvariation/korrelation

När två kontinuerliga variabler ökar/minskar tillsammans (positiv korrelation) eller i motsatt riktning (negativ korrelation), möjligtvis till följd av en gemensam tredje (dold) variabel.

### Krav/antaganden

-   Två kontinuerliga variabler/mätdata

-   Linjärt samband (kan göras linjär genom transformation om nödvändigt)

### Pearson korrelation

```{r}
plot( # Kolla alltid data
  penguins$bill_length_mm,
  penguins$bill_depth_mm
)
cor.test(
  penguins$bill_length_mm,
  penguins$bill_depth_mm
)
```

p-värdet tolkas som vanligt, cor är r^2^-värdet som beskriver styrka och riktning av korrelationen.

### Spearman (icke parametrisk)

```{r}
cor.test(
  penguins$bill_length_mm,
  penguins$bill_depth_mm,
  method = "spearman" # Specificera spearman
)
```

För denna kurs, ignorera `Warning: cannot compute exact p-value with ties`. Det betyder att det finns två av samma mätvärde vilket inte går att rangordna. (Om data är `c(25, 26, 26, 27)` är det `(1,2,3,4)` eller `(1,3,2,4)`?)

## Regression

Regression används då en kontinuerlig variabel kausalt orsakar en annan kontinuerlig variabel.

### Krav/antaganden

-   **Linjärt samband**

-   Normalfördelad (parametrisk)

-   Lika varians

### Linjär regression

Skapas med en formel liknande för ANOVA.

Med det högst biologiska antagandet att längre fenor orsakar högre kroppsvikt (genom att pingvinerna simmar fortare och därmed kan äta mer, säger vi) enligt en linjär trend, väljer vi att göra linjär regression.

```{r}
plot( # Scatterplot för att kolla sambandet
  penguins$flipper_length_mm,
  penguins$body_mass_g,
  pch = 16,
  cex = 0.4,
  col = "blue",
  xlab = "Flipper length [mm]",
  ylab = "Body mass [g]"
)

mass_by_flipper <- lm( # Skapa model
  body_mass_g ~ flipper_length_mm,
  data = penguins
)
summary(mass_by_flipper)
```

### Bootstrap

Alternativt med `lm()` och sedan `boot_summary()`.

```{r}
boot.anova_lm <- lm( # Skapa model
  body_mass_g ~ species * sex,   
  data = peng_boot ) 
boot_summary(boot.anova_lm)
```

### Predict

Om längden på fenorna orsakar kroppsmassa kan vi använda modellen för att förutse vikten på en pingvin baserat på fenornas längd.

Argumentet `newdata = data.frame()` måste innehålla samma kolumn namn som x-axeln och en vektor med de värden på x-axeln man vill förutspå y-värdet för.

```{r}
# Data frame med nya värden att förutspå. 
# Måste ha en kolumn med samma namn som x-axeln i modellen!
measured_flipper_length <- data.frame(
  flipper_length_mm = c(205, 221, 179)
)

estimated_weight <- predict(
  object = mass_by_flipper, # Modellen
  newdata = measured_flipper_length) # nya x-värden
```

```{r}
plot(
  penguins$flipper_length_mm,
  penguins$body_mass_g,
  
  pch = 16,
  col = alpha("blue", 0.2)
)
points(
  x = measured_flipper_length$flipper_length_mm,
  y = estimated_weight,
  
  pch = 16,
  col = "red"
)
```

## Chi-square

Det enda testet på kursen som hanterar frekvenser/räknedata. Till ära av Tobbes doktorsavhandling används här data om Gemsbock och Red hartbeest och deras observerade fördelning på fyra områden.

```{r}
bockar <- rbind(
  Gemsbock = c(FR = 5, CGA = 7, WMA = 12, NP = 67),
  Red_hartbeest = c(6,8,54,13)
)
bockar
```

```{r}

```

```{r}
#| eval: false
chisq.test()
fisher.test()
```

```{r}
#| eval: false
mean()
sum()
median()

aggregate()
rowMeans()
rowSums()
```

{{< pagebreak >}}

# Matte

## Lösa differentialekvationer

```{r}
# Funktion med ekvationssystemet att lösa
DE_fun <- function(times, # Intervall
                   y,     # Begynnelsevärden
                   parms  # Andra värden
) {
  # variabler att använda (från parms)
  alfa <- parms["alfa"]
  beta <- parms["beta"]
  delta <- parms["delta"]
  gamma <- parms["gamma"]
  
  # Begynnelsevärden (från y)
  B <- y["B"]
  P <- y["P"]
  
  # Differentialekvationen att lösa numeriskt
  #   (Minst 1 ekv. men sedan är det bara att lägga till fler ekv.
  #   på var sin rad. Varje ekv. måste ha ett begynnelsevärde &
  #   sedan returneras i result_vec)
  dB <- alfa * B - beta * B * P
  dP <- delta * B * P - gamma * P
  
  # Spara & returnera resultatet (ode() är lite speciell...)
  result_vec <- c( # Först som vektor
    dB,
    dP
  )
  result_list <- list(result_vec) # Sedan som lista
  return(result_list) #Returnera
}

# Vektor med alla tidssteg (t) att sätta in
DE_time_span <- seq(
  from = 0, # Början på intervall
  to = 30,  # Slut på intervall
  by = 0.1  # Steglängd
)

# Vektor med begynnelsevärden 
#   (enklast att namnge dem och sedan indexera med namnet i fun)
DE_init <- c(
  B = 200,
  P = 10
)

# Vektor med andra värden för formeln
#   (enklast att namnge dem och sedan indexera med namnet i fun)
DE_params <- c(
  alfa = 2.5,
  beta = 0.15,
  delta = 0.02,
  gamma = 1.5
)

# Lösa ekvationerna numeriskt
DE_sol <- ode(
  y = DE_init,           # Begynnelsevärden
  times = DE_time_span,  # Intervall
  func = DE_fun,         # Funktionen
  parms = DE_params,     # Andra värden
  method = "rk4"         # Runge-Kutta version 4
)
# Konvertera till data frame för att göra den lättare att hantera
DE_sol <- as.data.frame(DE_sol)


# Plotta dI respektive dS mot tid
plot( # Plot fönster & dI mot tid
  DE_sol$time,
  DE_sol$B,
  type = "l",
  
  col = "blue",
  
  xlab = "Time",
  ylab = "Värde på dIdt & dSdt",
  main = "Numerisk lösning för system av differentialekvationer"
)
lines( # Lägg till dS mot tid
  DE_sol$time,
  DE_sol$P,
  
  col = "darkorange"
)
```

{{< pagebreak >}}

# KvantBio

## Lotka-Volterra byte-predator modell

En specifik model som bygger på att lösa ett ekvationssystem av differentialekvationer.

![](lotka-volterra.PNG)

```{r}
# Funktion med ekvationssystemet att lösa
LV_fun <- function(times, # Intervall
                   y,     # Begynnelsevärden
                   parms  # Andra värden
) {
  # variabler att använda (från parms)
  alfa <- parms["alfa"]
  beta <- parms["beta"]
  delta <- parms["delta"]
  gamma <- parms["gamma"]
  
  # Begynnelsevärden (från y)
  B <- y["B"]
  P <- y["P"]
  
  # Differentialekvationen att lösa numeriskt
  dBdt <- (alfa * B - beta * B * P)
  dPdt <- (delta * B * P - gamma * P)
  
  # Spara & returnera resultatet
  result_vec <- c(
    dBdt,
    dPdt
  )
  result_list <- list(result_vec)
  return(result_list)
}

# Vektor med alla tidssteg (t) att sätta in
time_span_LV <- seq(
  0,
  30,
  by = 0.1
)

# Vektor med begynnelsevärden
init_LV <- c(
  B = 200,
  P = 10
)

# Vektor med andra värden för formeln
params_LV <- c(
  alfa = 2.5,    # Tillväxt byten
  beta = 0.15,   # Byten som äts
  delta = 0.02,  # Tillväxt predator
  gamma = 1.5    # Död predator
)

# Lösa ekvationerna numeriskt
sol_LV <- ode(
  y = init_LV,           # Begynnelsevärden
  times = time_span_LV,  # Intervall
  func = LV_fun,         # Funktionen
  parms = params_LV,     # Andra värden
  method = "rk4"         # Runge-Kutta version 4
)
sol_LV <- as.data.frame(sol_LV)


# Plotta antal insekter [milljoner] respektive spindlar [tusen] mot tid
plot(
  sol_LV$time,
  sol_LV$B,
  type = "l",
  
  col = "blue",
  
  xlab = "Time",
  ylab = "Number of individuals",
  main = "Lotka-Volterra model"
)
lines(
  sol_LV$time,
  sol_LV$P,
  
  col = "darkorange"
)
legend(
  "topright",
  legend = c("Insects [millions]", 
             "Spiders [thousands]"),
  
  lty = c(1, 1),
  col = c("blue",
          "darkorange")
)


# "Fasporträtt" (två pop. mot varandra där tiden blir att följa linjen)
plot(
  sol_LV$B,
  sol_LV$P,
  type = "l",
  
  col = "darkgreen",
  
  xlab = "Insects",
  ylab = "Spiders",
  main = "Fasporträtt"
)
```
