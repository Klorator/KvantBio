---
title: ".daddy_code"
author: "Rasmus Hammar"
format:
  pdf:
    highlight-style: atom-one
    toc: true
    number-sections: true
  html: 
    highlight-style: atom-one
    toc: true
    number-sections: true
    self-contained: true
    embed-resources: true
    self-contained-math: true
    code-overflow: wrap
include-in-header: 
  text: |
    \usepackage{fvextra}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
editor: visual
execute: 
  echo: true
---

# Allmänt

Lite allmänna funktioner som är bra att kunna.

## Paket & inläsning av data

För att installera ett paket.

```{r}
#| eval: false
# För att installera paketet som heter palmerpenguins
install.packages("palmerpenguins")

# För Stats
install.packages("MKinfer")
install.packages("lmboot")
install.packages("boot.pval")

# För Matte
install.packages("pracma")
install.packages("expm")
install.packages("deSolve")
```

För att använda funktioner i ett paket måste man ladda in paketet i R genom `library()`

```{r}
#| output: false
#| warning: false
# Exempel data
library(palmerpenguins)

# Stats
library(MKinfer)
library(lmboot)
library(boot.pval)

# Matte
library(pracma)
library(expm)
library(deSolve)

# KvantBio


```

För att läsa in data från t.ex. en .csv eller .txt fil. Öppna filen och identifiera vilka symboler som **sep**arerar kolumner samt används som **dec**imaltecken.

```{r}
#| eval: false
file.choose() # Returnerar vägen till filen man väljer, hitta fönstret med alt + tab.

my_data <- read.table(
  file = file.choose(), # Välj fil interaktivt, alt. filens sökväg som en text string
  header = TRUE, # Om det finns namn på kolumnerna
  sep = ",", # Här används ett kommatecken för att skilja på kolumner
  dec = "." # Här används en punkt som decimaltecken
)
```

För att titta på data kan man använda

```{r}
# View(penguins) # Öppnar som separat flik
head(penguins, # Printar de första 4 raderna
     n = 4)
tail(penguins, # Printar de sista 4 raderna
     n = 4)
```

För att skapa olika datastrukturer

## Variabel

```{r}
var_1 <- "Text/character string" # Någonting inuti "" är text
var_2 <- 25 # Nummer, för decimaltal 25.99
var_3 <- TRUE # Boolean, kan bara vara TRUE (T) eller FALSE (F)
var_4 <- NA # Not Available (NA), inte samma som "NA" (text string)!
var_5 <- NULL # Ingenting, tenderar att radera saker!
```

## Vektor

```{r}
vec_1 <- c() # Skapar en tom vektor
vec_1 <- c(36, 56, 48) # Skapa en vektor med tre värden
vec_1[4] <- 25 # Sätta in ett värde i index plats 4
vec_1 # Printa innehållet av variablen (vektorn)
```

```{r}
vec_1[2] # Printa innehållet i index 2
```

```{r}
vec_1[c(1,3)] # Printa index 1 och 3
```

Vektorer kan innehålla namn och indexeras med namn

```{r}
vec_2 <- c(element_1 = 99, element_2 = 100, element_3 = 101)
vec_2["element_4"] <- 102 # Sätt in ett värde med namn
vec_2
```

```{r}
vec_2["element_2"]
```

```{r}
vec_2[c("element_1", "element_3")]
```

## Data frame

```{r}
df <- data.frame( # Skapa en dataframe med kolumn_namn = vektor
  vec_1, # Kolumn 1, vec_1 från tidigare
  letters = LETTERS[1:4] # Kolumn 2, lite bokstäver
)
df
```

Man kan lägga till kolumner med \$

```{r}
df$col_3 <- vec_2 # Kolumn 3
df
```

Andra sätt att lägga till kolumner är med namn

```{r}
df["col4"] <- letters[1:4]
df
```

En kolumn kan användas med \$

```{r}
df$letters # Ger en vektor, samma som med df[["letters]]
```

Eller med indexering/namn, N.B. enkla \[ \] ger ett subset = en mindre del av samma objekt typ

```{r}
df[3] # Ger en data frame med enbart kolumn 3
df["col4"] # Ger en data frame med kolumn "col4"
```

medan dubbla \[\[ \]\] ger objektet inuti

```{r}
df[[1]] # Ger det "mindre objektet inuti", alltså en vektor i detta fall
```

Enkla `[ ]` kan indexeras med rader och kolumner samtidigt

```{r}
df[2] # Kolumn 2 (en data frame med en kolumn)
df[3,2] # Rad 3, kolumn 2 (en vektor av längd ett)
df[ ,2] # Alla rader, kolumn 2 (en vektor)
df[3, ] # Rad 3, alla kolumner (en data frame med en rad)
```

På tal om subsetting, för att ta ett subset av en data frame kan man filtrera rader baserat på ett kriterium

```{r}
penguins_chin <- penguins[penguins$species == "Chinstrap", ] 
# Utan komma läses det som att du vill filtrera kolumner! '==' är det matematiska 'lika med' (eftersom '=' är samma som '<-' )
head(penguins_chin)

penguins_heavy <- penguins[penguins$body_mass_g > 3500, ]
head(penguins_heavy)
```

Man kan även göra detta för att få en kolumn filtrerad/subset baserad på en annan kolumn.

```{r}
#| eval: false
penguins_chin_weight <- penguins$body_mass_g[penguins$species == "Chinstrap", ]
```

`Error in penguins$body_mass_g[penguins$species == "Chinstrap", ] :    incorrect number of dimensions`

Det blir en error därför att nu försöker man ta både rader och kolumner (2 dimensioner) på en kolumn (kolumn/vektor har bara 1 dimension) därför att \$ ger en vektor. Om vi istället provar utan extra kommatecken för att ange rader & kolumner samtidigt fungerar det (ger en vektor). Alternativt ange kolumnen med namn istället för med \$ (ger en mindre data frame).

```{r}
# Utan extra kommatecken
penguins_chin_weight <- penguins$body_mass_g[penguins$species == "Chinstrap"]
head(penguins_chin_weight)

# Ange kolumnen med namn
penguins_chin_weight <- penguins[penguins$species == "Chinstrap", "body_mass_g"]
head(penguins_chin_weight)
```

Vi kan även bli av med `NA` på ett kontrollerat sätt med den här metoden. Om man vill se till att vikt och näbblängd inte har `NA` kan man använda funtionen `in.na()` och operatorn `!`.

```{r}
is.na(NA) # Kolla om NA är NA
!is.na(NA) # ! negerar ett TRUE/FALSE uttryck

vec_NA <- c(NA, 50)
is.na(vec_NA) # Kolla vilka element som är NA
!is.na(vec_NA)
```

```{r}
# Alla rader där kolumnen body_mass_g inte är NA och alla kolumner
penguins_no_NA <- penguins[!is.na(penguins$body_mass_g), ]
# Alla rader där kolumnen bill_length_mm inte är NA och alla kolumner
penguins_no_NA <- penguins_no_NA[!is.na(penguins_no_NA$bill_length_mm), ]
data.frame(
  rows = c(penguins = nrow(penguins), no_NA = nrow(penguins_no_NA)),
  columns = c(penguins = ncol(penguins), no_NA = ncol(penguins_no_NA))
)
```

## Matris

Vi kan skapa matriser med `rbind()` (går även att använda `cbind()` men då placeras vektorerna vertikalt från det övre vänstra hörnet, istället för horisontellt). Med `rbind()` blir matrisen som den ser ut när man skriver den.

```{r}
rbind( # en "character matrix"
  c("a", "b"),
  c("c", "d")
)
cbind( # skillnaden med cbind()
  c("a", "b"),
  c("c", "d")
)

M <- rbind( # Skapar en matris radvis med namngivna rader och kolumner
  r1 = c(col1 = 0.90, col2 = 0, col3 = 0, col4 = 0, col5 = 0.45),
  r2 = c(          0,     0.45,        0,        0,           0),
  r3 = c(          0,     0.23,     0.45,        0,           0),
  r4 = c(          0,        0,     0.23,     0.45,           0),
  r5 = c(          0,        0,        0,     0.23,        0.20)
)
M
```

För matris matte se [Matte] sektionen.

Matriser kan indexeras ungefär på samma sätt som data frames.

```{r}
M[3, 2]
M[3:5, 2:3]
M[c(3,5), c(2,3)]
M[c("r3","r5"), c("col2","col3")]
```

## Lista (den riktiga listan)

I en vektor **måste** alla element vara av samma typ (numerisk/text osv.) och i en data frame **måste** alla kolumner (som är vektorer) vara lika långa.

Listor kan ha olika typer av objekt i sig och brukar användas för att bunta ihop olika objekt man vill hålla tillsammans. Till exempel är output från `t.test()` en lista.

```{r}
my_list <- list() # En tom lista
my_list$df_1 <- df # Lägg till en data frame med $
my_list[[2]] <- var_2 # Lägg till en variabel med index, N.B. [[]]
my_list[["plats_3"]] <- vec_2 # Lägg till en vektor med namn, N.B. [[]]
my_list
```

## Lite andra funktioner

Ett objekts typ heter "klass" och kan kollas med funktionen `class()`

```{r}
#| eval: false
class(var_1) # var_1 är text
class(var_2) # var_2 är numerisk
class(var_3) # var_3 är logical/boolean (TRUE/FALSE)
class(vec_1) # vec_1 är numerisk vektor
class(df) # df är en data frame
class(M) # M är en matris
class(my_list) # my_list är en lista
```

För att se till att någonting skrivs i konsollfönstret används `print()`

```{r}
print(var_1) # Tar enbart ett objekt! Se paste()

```

För att skriva ihop text m.m. används `paste()`, den tar dock enbart enskilda element (inte vektor/data frame/list

```{r}
message <- paste(
  "Hello", "world", var_1, 55, vec_2[3], # Alla objekt man vill skriva ihop
  sep = " " # Separator att infoga mellan varje objekt, här ett mellanslag
)
print(message)
```

Notera att `print()` enbart accepterar ett objekt, därav den vanliga kombinationen `print(paste(arg1, arg2))`.

```{r}
print(paste("Nu","klarar","vi","tentan!", sep = "! "))
```

Kolla längden på saker med

```{r}
length(vec_1) # Längden på en vektor
length(penguins) # Längden på en data frame är antalet kolumner
nrow(penguins) # För antalet rader i en data frame
ncol(penguins) # Antalet columner på en data frame
```

Få en vektor med namnen på kolumner

```{r}
colnames(penguins)
```

Få alla unika element i en vektor

```{r}
unique(penguins$species)
```

## Plotting

# Stats

### Tolkning av p-värde

Drivna över bristningsgränsen av kursen har en student blivit galen och vandrar, med slö blick, vilset i stadsskogen. Studenten betraktar ett träd. Hur högt är trädet? Vilsen betraktar studenten ett annat träd och stapplar vidare. Vad är sannolikheten att genomsnittshöjden på de träd studenten slumpmässigt observerar skiljer sig från genomsnittshöjden på alla träd i stadsskogen? Kanske de skiljer sig från träden i fjällen?

-   **H~0~** = Ingen skillnad mellan medelvärden

-   **H~1~** = Skillnad mellan medelvärden

p-värdet är sannolikheten att en stackars vilsen student slumpmässigt skulle betrakta dessa träd och konstatera att deras höjd skiljer sig från resten av skogens (alltså acceptera **H~1~**), när det i verkligheten inte finns någon skillnad mellan observerade och skogens medelvärden (alltså om **H~0~** är sann).

-   Om p-värde \> alfa, alltså p \> 0.05, säger vi att det inte finns en skillnad (acceptera **H~0~**).

-   Om p-värde \< alfa, alltså p \< 0.05, säger vi att det finns en skillnad (acceptera **H~1~**).

### Rapportera test

Rapportera alltid testets namn, statistiken (t.ex. t-/F-värdet), frihetsgrader och p-värde, samt en mening som ger slutsatsen/tolkningen av testet. Andra relevanta saker kan också inkluderas, såsom konfidens intervall.

Exempel: Förklarande mening (\[testets namn\], t(\[frihetsgrader\]) = \[värdet\], p = \[värdet\]).

> Det fanns en skillnad mellan Grupp 1 och den förväntade vikten (mu = 3000 g) enligt internet (One sample t-test, t(150) = 18.776, p \< 2.2e-16).

Tips från coachen, gör detta snyggare än jag...

### Formel notation

Många av funktionerna för de statistiska testen kan, eller måste, ges en formel. Formler har följande komponenter:

-   *Respons*, en kontinuerlig variabel vi vill förutspå, värdet på y-axeln

-   *Faktor*, en kategorisk variabel vilken delar in *Respons* i grupper (för regression är detta en kontinuerlig variabel som direkt orsakar *Respons*)

-   '\~', skiljer *Respons* från *Faktor*, alltså ger Vänster- och Högerled (`Respons ~ Faktor`)

-   '+', adderar en ytterligare *Faktor* (`Respons ~ Faktor_1 + Faktor_2`)

-   '\*', adderar en ytterligare *Faktor* **och** interaktionen (`Respons ~ Faktor_1 * Faktor_2` )

-   ':', adderar enbart interaktionen (`Respons ~ Faktor_1:Faktor_2`)

{{< pagebreak >}}

### Beslutsschema

![Stats flowchart 1](Beslutsschema-1.png)

{{< pagebreak >}}

![Stats flowchart 2](Beslutsschema-2.png)

{{< pagebreak >}}

![Stats flowchart 3](Beslutsschema-3.png)

{{< pagebreak >}}

![Stats flowchart 4](Beslutsschema-4.png)

{{< pagebreak >}}

## Binomial fördelning

Min binomiala studie:

-   20 försök

-   varje försök är Ja/Nej

-   37 % sannolikhet för Ja för varje oberoende försök

För att beräkna sannolikheten för utfall med binomial fördelning används `dbinom()` för att beräkna sannolikheten för exakt x antal gynsamma utfall,

```{r}
f5 <- dbinom(
  x = 5, # Exakt antal 'Ja'
  size = 20, # Totalt antal försök
  prob = 0.37 # Sannolikheten för försöket
)
print(paste("Sannolikhet att exakt fem av 20 försök blir 'Ja':", f5))
```

Dessa sannolikheter kan adderas.

```{r}
f6 <- dbinom(
  x = 6, # Exakt 6st Ja
  size = 20,
  prob = 0.37
)
print(paste("p att exakt 5-6st av 20 försök blir 'Ja':", (f5+f6)))
```

eller `1 - pbinom()` för att beräkna sannolikheten för alla utfall **över** det man anger.

```{r}
f15_20 <- (1 - pbinom(
  q = 14, # utfall över det angivna
  size = 20,
  prob = 0.37
))
print(paste("p att få 15 eller fler 'Ja':",f15_20))
```

Enbart `pbinom()` ger den motsatta sannolikheten (alltså 0-14 Ja) vilket är kompliment till 15-20 Ja. Använd `lower.tail = FALSE` för att få 15-20 Ja istället.

```{r}
f15_20_igen <- pbinom(
  q = 14,
  size = 20,
  prob = 0.37,
  lower.tail = FALSE # Istället för 1 - pbinom()
)
print(paste("p att få 15 eller fler 'Ja':",f15_20_igen))
```

## Skillnad mellan grupper

### T-test: krav/antaganden

### T-test: ensidigt

För att testa om en grupp med kontinuerlig data skiljer sig från ett känt eller teoretiskt väntevärde.

```{r}
grupp_1 <- penguins$body_mass_g[penguins$species == "Adelie"]

t.test(
  x = grupp_1, # En vektor
  mu = 3000    # Väntevärdet vi hittade på internet
)
```

#### Resultat:

Det fanns en skillnad mellan Grupp 1 och den förväntade vikten enligt internet (One sample t-test, t(150) = 18.776, p \< 2.2e-16).

### T-test: tvåsidigt

För att testa om det finns en skillnad mellan två grupper av kontinuerlig data.

```{r}
grupp_1 <- penguins$body_mass_g[penguins$species == "Adelie"]
grupp_2 <- penguins$body_mass_g[penguins$species == "Gentoo"]

t.test(
  x = grupp_1, # En vektor
  y = grupp_2, # En annan vektor
)
```

Alternativt sätt att skriva koden är med formel.

```{r}
peng_groups <- penguins[ which(penguins$species == "Adelie" | penguins$species == "Gentoo"), ]

t.test( # Respons = mätdata & Faktor = två olika arter (alltså två grupper)
  body_mass_g ~ species,
  data = peng_groups
)
```

#### Resultat:

Det fanns en skillnad mellan Grupp 1 och Grupp 2 (Welch two sample t-test, t(249.64) = -23.386, p \< 2.2e-16).

### T-test: paired/beroende

First rule of Crayfish Fight Club is you do not talk about Crayfish Fight Club.

Vi studerar kräftor och vill undersöka vilken effekt storleken på klorna har på vilken kräfta som vinner strider om resurser. För att göra detta snorklar vi någonstans tropiskt och letar efter kräftor som slåss. Efter några månader "hårt arbete" har vi samlat ihop följande data. Varje rad är storleken på klorna i cm med vinnare och förlorare i respektive kolumn.

```{r}
crayfish_fight_club <- data.frame(
  winner = c(86, 84, 75, 93, 102, 87, 88, 91, 87, 74),
  loser = c( 70, 79, 68, 85,  90, 89, 91, 82, 80, 69)
)
head(crayfish_fight_club)
```

Alltså består varje rad av mätningar på två individer där grupperingen är **beroende** på vem de jämförs med, och därför gör vi ett parat t-test.

```{r}
t.test(
  crayfish_fight_club$winner,
  crayfish_fight_club$loser,
  paired = TRUE
)
```

#### Resultat:

Paired t-test, t(9) = 3.5266, p = 0.006448, Signifikant.

```{r}
#| eval: false
t.test()
boot.t.test()
wilcox.test()

chisq.test()
fisher.test()

cor.test()
cor()

aov()
ANOVA.boot()
TukeyHSD()
p.adjust()

lm()
boot_summary()
predict()
```

```{r}
#| eval: false
mean()
sum()
median()

rowMeans()
rowSums()
```

# Matte

## Lösa differentialekvationer

```{r}
# Funktion med ekvationssystemet att lösa
DE_fun <- function(times, # Intervall
                   y,     # Begynnelsevärden
                   parms  # Andra värden
) {
  # variabler att använda (från parms)
  alfa <- parms["alfa"]
  beta <- parms["beta"]
  delta <- parms["delta"]
  gamma <- parms["gamma"]
  
  # Begynnelsevärden (från y)
  I <- y["I"]
  S <- y["S"]
  
  # Differentialekvationen att lösa numeriskt
  #   (Minst 1 ekv. men sedan är det bara att lägga till fler ekv.
  #   på var sin rad. Varje ekv. måste ha ett begynnelsevärde &
  #   sedan returneras i result_vec)
  dI <- alfa * I - beta * I * S
  dS <- delta * I * S - gamma * S
  
  # Spara & returnera resultatet (ode() är lite speciell...)
  result_vec <- c( # Först som vektor
    dI,
    dS
  )
  result_list <- list(result_vec) # Sedan som lista
  return(result_list) #Returnera
}

# Vektor med alla tidssteg (t) att sätta in
DE_time_span <- seq(
  from = 0, # Början på intervall
  to = 30,  # Slut på intervall
  by = 0.1  # Steglängd
)

# Vektor med begynnelsevärden 
#   (enklast att namnge dem och sedan indexera med namnet i fun)
DE_init <- c(
  I = 200,
  S = 10
)

# Vektor med andra värden för formeln
#   (enklast att namnge dem och sedan indexera med namnet i fun)
DE_params <- c(
  alfa = 2.5,
  beta = 0.15,
  delta = 0.02,
  gamma = 1.5
)

# Lösa ekvationerna numeriskt
DE_sol <- ode(
  y = DE_init,           # Begynnelsevärden
  times = DE_time_span,  # Intervall
  func = DE_fun,         # Funktionen
  parms = DE_params,     # Andra värden
  method = "rk4"         # Runge-Kutta version 4
)
# Konvertera till data frame för att göra den lättare att hantera
DE_sol <- as.data.frame(DE_sol)


# Plotta dI respektive dS mot tid
plot( # Plot fönster & dI mot tid
  DE_sol$time,
  DE_sol$I,
  type = "l",
  
  col = "blue",
  
  xlab = "Time",
  ylab = "Värde på dIdt & dSdt",
  main = "Numerisk lösning för system av differentialekvationer"
)
lines( # Lägg till dS mot tid
  DE_sol$time,
  DE_sol$S,
  
  col = "darkorange"
)
```

# KvantBio

## Lotka-Volterra byte-predator modell

En specifik model som bygger på att lösa ett ekvationssystem av differentialekvationer.

```{r}
# Funktion med ekvationssystemet att lösa
LV_fun <- function(times, # Intervall
                   y,     # Begynnelsevärden
                   parms  # Andra värden
) {
  # variabler att använda (från parms)
  alfa <- parms["alfa"]
  beta <- parms["beta"]
  delta <- parms["delta"]
  gamma <- parms["gamma"]
  
  # Begynnelsevärden (från y)
  I <- y["I"]
  S <- y["S"]
  
  # Differentialekvationen att lösa numeriskt
  dIdt <- (alfa * I - beta * I * S)
  dSdt <- (delta * I * S - gamma * S)
  
  # Spara & returnera resultatet
  result_vec <- c(
    dIdt,
    dSdt
  )
  result_list <- list(result_vec)
  return(result_list)
}

# Vektor med alla tidssteg (t) att sätta in
time_span_LV <- seq(
  0,
  30,
  by = 0.1
)

# Vektor med begynnelsevärden
init_LV <- c(
  I = 200,
  S = 10
)

# Vektor med andra värden för formeln
params_LV <- c(
  alfa = 2.5,
  beta = 0.15,
  delta = 0.02,
  gamma = 1.5
)

# Lösa ekvationerna numeriskt
sol_LV <- ode(
  y = init_LV,           # Begynnelsevärden
  times = time_span_LV,  # Intervall
  func = LV_fun,         # Funktionen
  parms = params_LV,     # Andra värden
  method = "rk4"         # Runge-Kutta version 4
)
sol_LV <- as.data.frame(sol_LV)


# Plotta antal insekter [milljoner] respektive spindlar [tusen] mot tid
plot(
  sol_LV$time,
  sol_LV$I,
  type = "l",
  
  col = "blue",
  
  xlab = "Time",
  ylab = "Number of individuals",
  main = "Lotka-Volterra model"
)
lines(
  sol_LV$time,
  sol_LV$S,
  
  col = "darkorange"
)
legend(
  "topright",
  legend = c("Insects [millions]", 
             "Spiders [thousands]"),
  
  lty = c(1, 1),
  col = c("blue",
          "darkorange")
)


# "Fasporträtt" (två pop. mot varandra där tiden blir att följa linjen)
plot(
  sol_LV$I,
  sol_LV$S,
  type = "l",
  
  col = "darkgreen",
  
  xlab = "Insects",
  ylab = "Spiders",
  main = "Fasporträtt"
)
```
